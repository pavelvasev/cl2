Может нам и не стоит так упарываться за задачный язык.
Потому что его надо реализовывать на всех платформах получается.
А ведь там масса операций, даже str.contains.. и прочие math.sin.. странно если их все переделывать..
но с другой стороны если ими пользоваться то - программа получится кросс-платформенная
(в смысле платформ - Си, js и т.п.)

*******
Отличие процессов от задач таки существенно, хоть я и вижу что они "похожи" в плане языка.
- в процессах {} есть парент внешний, к кому надо цепляться, а в задачах - он внутренний.
- у процессов надо согласованно подавать входные аргументы. если несогласованно то будут промежуточные состояния некорректные и неожиданные (и задержки на лишние вычисления).
а задачам без разницы - у них встроено ожидание подачи (когда-все).
- у задач допустим по виду name(a,b,c)-синтаксис а у процессов такого не хотелось бы интуитивно.
и процессам кстати собачка норм, а вот у задач - очень не идет как-то.

***************************
О частичном порядке

С одной стороны вроде как зачем он нужен. Но. Частичный порядок нам дает работать с реактивностью:

text label=(+ "x=" @x)
x:= 0
react (dom.event @btn "click") {: x.submit( x.get() + 1 ) :}

но частичный ли это порядок? или в создании text это уже процесс и он ну создает связь ячейки с аргументом процесса? ну а то что он там внутри реагирует то и молодец.
а в вызове функции - связь не создается а берется значение..

---
лесом эти частичные вычисления там, где я ожидаю обычные последовательные.
вот просто лесом. от них одна путаница, я это осознанно осознаю теперь.
надо провести некую демаркацию прямо ясную.

и кстати последовательное должно генерить простой код, а не сумашествия из процессов, желательно.

но с другой стороны и удобно создать процесс и работать с ним.. не ожидая его завершения.. вот как быть? промисы явные вводить не хотелось бы..

******************************
Про языки интерпретаторов.

Есть у нас процессоры. Ну для них мы пишем на С++, там производительность.
Как только переходим на питоны - она сразу просаживается, говорить о ней не приходится (с исключениями случаев numba-njit). Но питоны используются как языки организации связи между компонентами (написанными на С++ / cuda и т.п.). Для организации связей, которые редко перестраиваются, не жалко потратить времени на исполнение. За это мы получаем гибкость - не надо программу перекомпилировать (а есть еще преимущества?).
И много не теряем - наладка связей это небольшая часть программы.

В этом смысле Слон играет некую подобную роль.
