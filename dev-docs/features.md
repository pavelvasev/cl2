----
let вынесено как особая форма на текстовом уровне.
и дополнитльно сделан оператор := который работает как let но без скобочек этих странных.

****
вообще найдено уже 3 особых формы
- синтаксиса
  добавляет свой синтаксис
- объектного преобразования (со своим синтаксисом или со стандартным)
  преобразует список объектов пропарсенных, заменяя себя на что-то другое.
- текстовая - генерит свой текст. 
****

объектная и текстовая особые формы - к компилятору не относятся они внешний для него параметр.

****
create-binding делается в привязке к объекту.
ну а точнее - объекту на release ставится удаление биндинга.
надо ли ему хранить сами биндинги еще вопрос.

*********************
сборка набора оставшихся позиционных параметров в общий параметр с маркером *
сборка набора оставшихся именованных параметров в общий параметр с маркером **

подстановка набора позиционных параметров с маркером *
подстановка набора именованных параметров с маркером *

**********************
статическая проверка типов. каждый тип должен предоставить функцию check_params
на вход берет имена на выходе - списки normal, rest_positional, rest_named.

**********************
F-DELAYED-EATER
преобразователь каналов с переводом в следующий логический такт и уборкой дублирующихся

**********************
F-ANNOTATE
к ячейкам и каналам нужна аннотация - что они такое. надо для отладки. а то не очень понятно что когда и почему происходит. 
итого каждый объект синхронизации пусть имеет title.

причем аннотация должна получаться путем своего title и вызова title() к чему приаттачен данный примитив. функция потому, что хост-примитив могут тоже приаттачить, но когда-нибудь

*********************
F-POSITIONAL-RENAME
пишем someobj @a @b @c 4 5 6
и они идут как params.0, params.1 и т.п.
и надо как в питоне - переименовать их.

***********************
F-BIND-OBJECTS
идея - чтобы bind работала и с объектами.
т.е. есть obj1 и пишем bind @obj1 @x
и это можно, если у obj1 есть примитив output

правда тогда не получится передавать в ячейки сами объекты, 
но для этого можно сделать ref @obj..

***************************
F-FEATURE-OBJ-NAMES-UNIQ
оказалось что вещи типа
foo alfa=(add @beta 10 (counter (timer))) sigma=(counter (timer) 111)
порождают одинаковые идентификаторы (типа _counter)._

в общем среди решений пробовал префиксы но там сложнго. в итоге на уровне пег-парсера порождаются идентификаторы с уник. счетчиком.


**************************
F-COMPILER-PLUGINS

Решено компилятор оснащать плагинами а то там много фич которые захочется в будущем менять.
Плагин подключается передачей к нему управления в функцию setup(state) где state корневое
состояние. Плагин может вписаться в него.

Используется точка сопряжения state.space - одни плагины вызывают методы из нее, другие туда добавляют методы.

**************************
F-MODULE-PATHS

модули резолвятся следующим образом
import localname="someid/some/path"

* если someid это . то тогда some/path локальный
* иначе
используется карта импортов которая резолвит someid в каталог или в путь
(по аналогии import maps в js) и далее приписывается some/path.

таким образом, 
import d="std/dom/dom.cl"
загрузит файл lib/dom/dom.cl если std указано в карте импортов как путь к каталогу lib.

*********************
Принцыпы CL2 принципиальные.

- канал, ячейка, метод - отдельные сущности

- стыковка объектов (один в другой) типа делаем окружения. иерархичные причем.

- трансляция и затем исполнение. не принципиально но - позволяет использовать компилятор внешний для неитнересных задач таких как работа с окружением, визуальная отладка..
- ну вроде как не принципиально какой целевой язык. делаем рантайм на нем а вокруг - сгенерированный код опирающийся на рантайм.
- модульность. под ней имеется ввиду пространства имен. это очень важно оказалось.
т.е. подключаемый модуль не вписывает свои штуки в текущий контекст (окружение) а остается как бы внутрях своего окружения. ну тут возникает задача мержить повторно использьуемые модули чтобы копий не плодить, она решается.

- проверка параметров при компиляции. т.е. если передают неверное кол-во параметров или неизвестный параметр именованный - выдать ошибку. практика CL показала что это очень частые ошибки и их долго ловить.
как следствие - некоторые параметры надо описать как входные, причем порядок важен (для позиционной записи передачи параметров)

- потом надо еще сделать и ссылочную проверку - ссылаемся на прибинденный подобъект так надо проверить есть ли он там.

- смешнивание позиционных и именованных параметров аля Питон. Признано очень удобным моим личным опытом юзанья Питона. Возможность сбора неограниченного кол-ва позиционных *rest и **rest именованных параметров. Подстановка параметров, т.е. print *arr


====================
F-PLATFORM-CODE
сделано {: a b c | code :} для вставки платформенного кода. оч удобно.

------
F-CHILDREN-BLOCK
иногда надо не автоматом создавать детей у объекта а передать ему в параметрах.
например для реализации repeater, if, да и вообще всех кто может трактовать содержание вложенных {} по-особому. 

Реализовано как в руби - если в имени параметра есть & то ему передается описание содержимого {} а не сами объекты. Передаются сейчас пока в форме функции вида foo: parent -> void
которая создает процесс описанный в {} включая объектов детей и цепляет все это в указанный parent.
Можно вызывать несколько раз.

F-CHILDREN-BLOCK-PARAMS
возможность передавать чилдренов в форме
foo { |x y|
  std.print @x @y
}
тогда они поступают в форме функции у которой доп. параметры - ячейки/каналы.

F-PARAM-OBJECTS
Запись вида alfa b={ sigma gamma }
т.е. в параметр b можно передавать блоки. Равно как и блоки вида { |x y z| .... }.
Правило такое же как и с детьми - передаются в форме функции с параметрами - целевым родителем и позиционными параметрами-ячейками/каналами.

F-IF
Операция if
if @cond @then_value @else_value
if @cond {
  then-block
} else {
  else-block
}

-------------------------
F-DEFAULT-CL
Дефолтные вещи, т.е. объекты и формы доступные всюду, - задавать в том числе на cl-языке.

F-STATIC-VALUES
Проблема - some @func и вот func имеется ввиду это функция где-то выше определенная.
а мы начинаем пытаться ее забиндить в аргумент.
Поэтому - вводим отслеживание статичных значений.

----------------------------
P-SPECIAL-NAMES

Проблема - в операциях могут быть символы всякие корявые типа +, < и т.п.
и так функции в js нельзя называть да и в других языках иногда тоже
с этим необходимо что-то делать.

варианты:
F-SAFE-NAME
поэтому надо преобразовывать cl-имена в варианты, безопасные для целевого языка
- при определении объектов и функций
- при их использовании в basis и по ссылкам тоже
кстати про ссылки - значит надо разрешить точку в именах... (т.е. используем оператор доступа к полям объекта из целевого языка)

единственное проблема - как в ссылках ссылаться на функции с такими именами?
т.е. @+ вряд ли получится..

F-ALIAS
мы делаем нормальное, платформенное. например "plus"
а потом говорим alias "plus" "+"
и она уже ползет пусть в env и там делает как надо..

-------
F-MATH-OPERATOR
Необходимо поддержать синтаксис привычный для математических операторов,
таких как a + b. Он отличается от list-варианта: (+ a b).

*************************
F-LET-SHORTCUT-OPERATOR
Писать let a = (+ 10 20) оказалось скучно - постоянные скобки.
Вводится оператор := которому скобки не нужны такие.
Пример: a := + 10 20
Потом на его основе можно будет сделать аналогичное для return - там тоже скобки лишние. И мб для if, else.

----
F-NODE-IMPORT F-JS-IMPORT 
возможность импорта js-файлов и node:-библиотек.
```
import cp="node:child_process"
import f="./file.js"
```

*****************************
F-LIST-COMM
функция посылки всех элементов списка в канал
и обратно - сборка элементов из канала в список.
кажется универсально и удобно

submit-list @list @channel
gather-list @channel @list

но кстати:
(gather-list @channel) -> list
(submit-list @list) -> channel
т.е. оно не куда-то сабмитит, а создает свой канал и в него сабмитит.
так почему-то лучше.

как назвать?
gather-list
gather-events наверное лучше

***************************
F-EVENTS-REDUCE
получает сообщения и обрабатывает их накапливая, и выдавая результат
reduce @channel '' {: val acc | acc + val :}
- в целом это реакция, такая форма
- gather-list можно выразить через reduce

*************************
F-PIPES
F-PIPES-INPUT-ARG
pipe-ы вернуть
при этом проверить что идет позиционная подстановка input-аргумента.
т.е. если сигнатура foo (input alfa beta) то тогда
some | foo alfa beta
а input подставляется пайпой.

Обновленное. Надо не input трогать а позиционный параметр подставлять.
// правило такое:
// сдвигаем параметры заданные позиционно вправо 
// и output левого элемента ставим первым таким параметром.
// ну если там был input и не совпало.. посмотрим, может ошибка.

***************************
F-OPERATOR-MINUS
глюк парсера.. он не видит "-" как имя оператора.. а думает это число.
т.е. (@n -1) не работает, а (@n - 1) работает.
надо обрабатывать особо эту ситуацию. так и сделано.

***************************
F-CHILDREN-PARAM
подстановка children.
Мы решили что {}-объекты это просто функция, которая порождает набор объектов (в т.ч. каждый вызов функции это объект технически - объект вызова).
Это позволяет делать так -- когда пишем map @x { y | f(y) } то {}..-часть это второй позиционный аргумент для map.
Но есть отдельные ситуации, когда мы хотим явно выделить {}-блок как "детей". 
Чтобы потом например вставить этих детей в данный объект. (вызвать фунркцию их активации)
Например это важно для описания интерфейсов, 3д графики, и прочих dsl.
Однако у нас может быть масса позиционных аргументов, которым бы при этом хотелось бы оставлять значения по умолчанию. Итого получается, что параметр для вставки {}-блока надо выделять особо, чтобы блок не пошел в очередной позиционный аргумент, а установился в нужный параметр.

Решение
Вводится children& имя. (затем кстати перенести & в начало, как в руби и питоне и js)
Если children-имя есть, то анализируется последний позиционный аргумент.
Если он является {}-функцией, то он переименовывается в children-параметр.
Это кстати можно и удобно сделать на уровне метода формы - check_params, задав renamed.

Возникает пара особых случаев
- указан rest-параметр.
- хочется получать несколько {}-параметров. решение - разбирайтесь сами.

****************************
R-COHERENT-MIND
мы разрешили писать процессы в функциональном стиле в виде
foo a=@x b=((2 * @x)+1)
но когда мы так пишем то считаем, что при смене x оба параметра a b посчитаются
и затем синхронно передадутся в foo. Однако технически это не так.

F-COHERENT-MIND 
Идея решения в том что каналы и прочие синхрообъекты при соединении пусть распространяют приоритет.
Если канал x связывается как источник для y то y.priority = x.priority-1.
При этом приоритет у каналов пусть идет общий в контексте объекта к которому они прикреплены.
Объекты выставляют запуск функций в реакциях, но порядок этих функций пусть учитывает этот приоритет.
Тогда получится, что в "подвыражениях" приоритет выше, их реакции выполняются раньше, а реакция конечного потребителя - позже.
Но конечно лучше ввести какую-то модель дискретного времени. По сути вышесказанное это оно и есть но в форме приоритетов.

p.s. Может быть стоило сделать это на основе лексической вложенности. А не на основе соединения примитивов синхронизации.

Подтверждаю, сложно получилось. Очень сложно и всегда нелогично работает. Надо какой-то проще механизм.
Контрпример:
x:=5
r1: react .. { set x=10 }
r2: react @r1.output { assert x==10 } // не сработает
см tests.official/dict/main.cl

*****************************
F-SKOBKI
Сделан режим что можно опционально ставить скобочки в выражениях.
т.е. можно написать теперь и по станорму
`a := alfa @beta (gamma @x) teta=(sigma @a @x)`
и по новому
* `a := alfa(@beta,gamma @x,teta=sigma @a @x)`
* `a := alfa(@beta,gamma(@x),teta=sigma @a @x)`
* `a := alfa(@beta,gamma(@x),teta=sigma(@a,@x))`
При этом собачки для ссылок на переменные пока оставлены.
В будущем в скобочном варианте их можно будет убрать.

При этом последний аргумент-функция вида {...} можно оставлять за скобками. Так красиво (не протаскиваем скобку аргументов в конец после {}-блока ) и воспринимается естественно.
И так сделано в Руби и в Котлине. Ну и в Питоне кстати тоже с их with и прочими формами.

Но кстати оказалось что я сделал что если начали делать скобки то внутри только со скобками можно.
Может оно и к лучшему. По крайней мере точно позволит писать вызовы dict() а не dict что потом позволит убрать собачки.

F-SKOBKI-NOSPACE И допом оказался неверный парсинг. Итого пока - необходимо в этом режиме скобку ставить сразу после имени фичи. Без пробелов. Т.е. dict() это да, а dict () это нет.


***************************
F-NAMED-REST
сделана сборка именованных параметров. Т.о. в in теперь можно писать
in { rest**: cell } и в ячейку rest будут попадать все неуказанные в in именованные параметры.
Их потом можно собрать значения через extract.

****************************
F-RETURN-SCOPE
return возвращает значение не для любого {}-блока, а для объявленной выше функции.