----
let вынесено как особая форма на текстовом уровне.
и дополнитльно сделан оператор := который работает как let но без скобочек этих странных.

****
вообще найдено уже 3 особых формы
- синтаксиса
  добавляет свой синтаксис
- объектного преобразования (со своим синтаксисом или со стандартным)
  преобразует список объектов пропарсенных, заменяя себя на что-то другое.
- текстовая - генерит свой текст. 
****

объектная и текстовая особые формы - к компилятору не относятся они внешний для него параметр.

****
create-binding делается в привязке к объекту.
ну а точнее - объекту на release ставится удаление биндинга.
надо ли ему хранить сами биндинги еще вопрос.

*********************
сборка набора оставшихся позиционных параметров в общий параметр с маркером *
сборка набора оставшихся именованных параметров в общий параметр с маркером **

подстановка набора позиционных параметров с маркером *
подстановка набора именованных параметров с маркером *

**********************
статическая проверка типов. каждый тип должен предоставить функцию check_params
на вход берет имена на выходе - списки normal, rest_positional, rest_named.

**********************
F-DELAYED-EATER
преобразователь каналов с переводом в следующий логический такт и уборкой дублирующихся

**********************
F-ANNOTATE
к ячейкам и каналам нужна аннотация - что они такое. надо для отладки. а то не очень понятно что когда и почему происходит. 
итого каждый объект синхронизации пусть имеет title.

причем аннотация должна получаться путем своего title и вызова title() к чему приаттачен данный примитив. функция потому, что хост-примитив могут тоже приаттачить, но когда-нибудь

*********************
F-POSITIONAL-RENAME
пишем someobj @a @b @c 4 5 6
и они идут как params.0, params.1 и т.п.
и надо как в питоне - переименовать их.

***********************
F-BIND-OBJECTS
идея - чтобы bind работала и с объектами.
т.е. есть obj1 и пишем bind @obj1 @x
и это можно, если у obj1 есть примитив output

правда тогда не получится передавать в ячейки сами объекты, 
но для этого можно сделать ref @obj..

***************************
F-FEATURE-OBJ-NAMES-UNIQ
оказалось что вещи типа
foo alfa=(add @beta 10 (counter (timer))) sigma=(counter (timer) 111)
порождают одинаковые идентификаторы (типа _counter)._

в общем среди решений пробовал префиксы но там сложнго. в итоге на уровне пег-парсера порождаются идентификаторы с уник. счетчиком.


**************************
F-COMPILER-PLUGINS

Решено компилятор оснащать плагинами а то там много фич которые захочется в будущем менять.
Плагин подключается передачей к нему управления в функцию setup(state) где state корневое
состояние. Плагин может вписаться в него.

Используется точка сопряжения state.space - одни плагины вызывают методы из нее, другие туда добавляют методы.

**************************
F-MODULE-PATHS

модули резолвятся следующим образом
import localname="someid/some/path"

* если someid это . то тогда some/path локальный
* иначе
используется карта импортов которая резолвит someid в каталог или в путь
(по аналогии import maps в js) и далее приписывается some/path.

таким образом, 
import d="std/dom/dom.cl"
загрузит файл lib/dom/dom.cl если std указано в карте импортов как путь к каталогу lib.

*********************
Принцыпы CL2 принципиальные.

- канал, ячейка, метод - отдельные сущности

- стыковка объектов (один в другой) типа делаем окружения. иерархичные причем.

- трансляция и затем исполнение. не принципиально но - позволяет использовать компилятор внешний для неитнересных задач таких как работа с окружением, визуальная отладка..
- ну вроде как не принципиально какой целевой язык. делаем рантайм на нем а вокруг - сгенерированный код опирающийся на рантайм.
- модульность. под ней имеется ввиду пространства имен. это очень важно оказалось.
т.е. подключаемый модуль не вписывает свои штуки в текущий контекст (окружение) а остается как бы внутрях своего окружения. ну тут возникает задача мержить повторно использьуемые модули чтобы копий не плодить, она решается.

- проверка параметров при компиляции. т.е. если передают неверное кол-во параметров или неизвестный параметр именованный - выдать ошибку. практика CL показала что это очень частые ошибки и их долго ловить.
как следствие - некоторые параметры надо описать как входные, причем порядок важен (для позиционной записи передачи параметров)

- потом надо еще сделать и ссылочную проверку - ссылаемся на прибинденный подобъект так надо проверить есть ли он там.

- смешнивание позиционных и именованных параметров аля Питон. Признано очень удобным моим личным опытом юзанья Питона. Возможность сбора неограниченного кол-ва позиционных *rest и **rest именованных параметров. Подстановка параметров, т.е. print *arr


====================
F-PLATFORM-CODE
сделано {: a b c | code :} для вставки платформенного кода. оч удобно.

------
F-CHILDREN-BLOCK
иногда надо не автоматом создавать детей у объекта а передать ему в параметрах.
например для реализации repeater, if, да и вообще всех кто может трактовать содержание вложенных {} по-особому. 

Реализовано как в руби - если в имени параметра есть & то ему передается описание содержимого {} а не сами объекты. Передаются сейчас пока в форме функции вида foo: parent -> void
которая создает процесс описанный в {} включая объектов детей и цепляет все это в указанный parent.
Можно вызывать несколько раз.

F-CHILDREN-BLOCK-PARAMS
возможность передавать чилдренов в форме
foo { |x y|
  std.print @x @y
}
тогда они поступают в форме функции у которой доп. параметры - ячейки/каналы.

F-PARAM-OBJECTS
Запись вида alfa b={ sigma gamma }
т.е. в параметр b можно передавать блоки. Равно как и блоки вида { |x y z| .... }.
Правило такое же как и с детьми - передаются в форме функции с параметрами - целевым родителем и позиционными параметрами-ячейками/каналами.

F-IF
Операция if
if @cond @then_value @else_value
if @cond {
  then-block
} else {
  else-block
}

-------------------------
F-DEFAULT-CL
Дефолтные вещи, т.е. объекты и формы доступные всюду, - задавать в том числе на cl-языке.

F-STATIC-VALUES
Проблема - some @func и вот func имеется ввиду это функция где-то выше определенная.
а мы начинаем пытаться ее забиндить в аргумент.
Поэтому - вводим отслеживание статичных значений.

----------------------------
P-SPECIAL-NAMES

Проблема - в операциях могут быть символы всякие корявые типа +, < и т.п.
и так функции в js нельзя называть да и в других языках иногда тоже
с этим необходимо что-то делать.

варианты:
F-SAFE-NAME
поэтому надо преобразовывать cl-имена в варианты, безопасные для целевого языка
- при определении объектов и функций
- при их использовании в basis и по ссылкам тоже
кстати про ссылки - значит надо разрешить точку в именах... (т.е. используем оператор доступа к полям объекта из целевого языка)

единственное проблема - как в ссылках ссылаться на функции с такими именами?
т.е. @+ вряд ли получится..

F-ALIAS
мы делаем нормальное, платформенное. например "plus"
а потом говорим alias "plus" "+"
и она уже ползет пусть в env и там делает как надо..

-------
F-MATH-OPERATOR
Необходимо поддержать синтаксис привычный для математических операторов,
таких как a + b. Он отличается от list-варианта: (+ a b).

*************************
F-LET-SHORTCUT-OPERATOR
Писать let a = (+ 10 20) оказалось скучно - постоянные скобки.
Вводится оператор := которому скобки не нужны такие.
Пример: a := + 10 20
Потом на его основе можно будет сделать аналогичное для return - там тоже скобки лишние. И мб для if, else.

----
F-NODE-IMPORT F-JS-IMPORT 
возможность импорта js-файлов и node:-библиотек.
```
import cp="node:child_process"
import f="./file.js"
```

*****************************
F-LIST-COMM
функция посылки всех элементов списка в канал
и обратно - сборка элементов из канала в список.
кажется универсально и удобно

submit-list @list @channel
gather-list @channel @list

но кстати:
(gather-list @channel) -> list
(submit-list @list) -> channel
т.е. оно не куда-то сабмитит, а создает свой канал и в него сабмитит.
так почему-то лучше.

как назвать?
gather-list
gather-events наверное лучше

***************************
F-EVENTS-REDUCE
получает сообщения и обрабатывает их накапливая, и выдавая результат
reduce @channel '' {: val acc | acc + val :}
- в целом это реакция, такая форма
- gather-list можно выразить через reduce

*************************
F-PIPES
F-PIPES-INPUT-ARG
pipe-ы вернуть
при этом проверить что идет позиционная подстановка input-аргумента.
т.е. если сигнатура foo (input alfa beta) то тогда
some | foo alfa beta
а input подставляется пайпой.

Обновленное. Надо не input трогать а позиционный параметр подставлять.
// правило такое:
// сдвигаем параметры заданные позиционно вправо 
// и output левого элемента ставим первым таким параметром.
// ну если там был input и не совпало.. посмотрим, может ошибка.

***************************
F-OPERATOR-MINUS
глюк парсера.. он не видит "-" как имя оператора.. а думает это число.
т.е. (@n -1) не работает, а (@n - 1) работает.
надо обрабатывать особо эту ситуацию. так и сделано.

***************************
F-CHILDREN-PARAM
подстановка children.
Мы решили что {}-объекты это просто функция, которая порождает набор объектов (в т.ч. каждый вызов функции это объект технически - объект вызова).
Это позволяет делать так -- когда пишем map @x { y | f(y) } то {}..-часть это второй позиционный аргумент для map.
Но есть отдельные ситуации, когда мы хотим явно выделить {}-блок как "детей". 
Чтобы потом например вставить этих детей в данный объект. (вызвать фунркцию их активации)
Например это важно для описания интерфейсов, 3д графики, и прочих dsl.
Однако у нас может быть масса позиционных аргументов, которым бы при этом хотелось бы оставлять значения по умолчанию. Итого получается, что параметр для вставки {}-блока надо выделять особо, чтобы блок не пошел в очередной позиционный аргумент, а установился в нужный параметр.

Решение
Вводится children& имя. (затем кстати перенести & в начало, как в руби и питоне и js)
Если children-имя есть, то анализируется последний позиционный аргумент.
Если он является {}-функцией, то он переименовывается в children-параметр.
Это кстати можно и удобно сделать на уровне метода формы - check_params, задав renamed.

Возникает пара особых случаев
- указан rest-параметр.
- хочется получать несколько {}-параметров. решение - разбирайтесь сами.

****************************
R-COHERENT-MIND
мы разрешили писать процессы в функциональном стиле в виде
foo a=@x b=((2 * @x)+1)
но когда мы так пишем то считаем, что при смене x оба параметра a b посчитаются
и затем синхронно передадутся в foo. Однако технически это не так.

F-COHERENT-MIND 
Идея решения в том что каналы и прочие синхрообъекты при соединении пусть распространяют приоритет.
Если канал x связывается как источник для y то y.priority = x.priority-1.
При этом приоритет у каналов пусть идет общий в контексте объекта к которому они прикреплены.
Объекты выставляют запуск функций в реакциях, но порядок этих функций пусть учитывает этот приоритет.
Тогда получится, что в "подвыражениях" приоритет выше, их реакции выполняются раньше, а реакция конечного потребителя - позже.
Но конечно лучше ввести какую-то модель дискретного времени. По сути вышесказанное это оно и есть но в форме приоритетов.

p.s. Может быть стоило сделать это на основе лексической вложенности. А не на основе соединения примитивов синхронизации.

Подтверждаю, сложно получилось. Очень сложно и всегда нелогично работает. Надо какой-то проще механизм.
Контрпример:
x:=5
r1: react .. { set x=10 }
r2: react @r1.output { assert x==10 } // не сработает
см tests.official/dict/main.cl

*****************************
F-SKOBKI
Сделан режим что можно опционально ставить скобочки в выражениях.
т.е. можно написать теперь и по станорму
`a := alfa @beta (gamma @x) teta=(sigma @a @x)`
и по новому
* `a := alfa(@beta,gamma @x,teta=sigma @a @x)`
* `a := alfa(@beta,gamma(@x),teta=sigma @a @x)`
* `a := alfa(@beta,gamma(@x),teta=sigma(@a,@x))`
При этом собачки для ссылок на переменные пока оставлены.
В будущем в скобочном варианте их можно будет убрать.

При этом последний аргумент-функция вида {...} можно оставлять за скобками. Так красиво (не протаскиваем скобку аргументов в конец после {}-блока ) и воспринимается естественно.
И так сделано в Руби и в Котлине. Ну и в Питоне кстати тоже с их with и прочими формами.

Но кстати оказалось что я сделал что если начали делать скобки то внутри только со скобками можно.
Может оно и к лучшему. По крайней мере точно позволит писать вызовы dict() а не dict что потом позволит убрать собачки.

F-SKOBKI-NOSPACE И допом оказался неверный парсинг. Итого пока - необходимо в этом режиме скобку ставить сразу после имени фичи. Без пробелов. Т.е. dict() это да, а dict () это нет.


***************************
F-NAMED-REST
сделана сборка именованных параметров. Т.о. в in теперь можно писать
in { rest**: cell } и в ячейку rest будут попадать все неуказанные в in именованные параметры.
Их потом можно собрать значения через extract.

****************************
F-RETURN-SCOPE
return возвращает значение не для любого {}-блока, а для объявленной выше функции.
это оказалось полезно в связи с вводам F-SEQ и там например мы делаем if и надо выйти из функции вообще. С return который возвращает на уровне блока - такое не получилось бы.
Поэтому теперь return находит ближайшую функцию где он сидит и ее завершает.

update. 
новая фича - F-SKIP-RETURN-SCOPE
Оказалось это таки не очень удобно. И в том же js ретурн работает внутри лямбды.
А вот в Руби он работает на метод и это выносит мозг, я вспомнил. Вечно помнить куды что.

Поэтому сделано другое. Мы все еще используем лексическое return_scope. И вводим его для всех {}-блоков. КРОМЕ НЕКОТОРЫХ. Для if, else не вводим. И все. 

update
оказалось что return внутри {}-блоков внутри if тоже нужен:
x := if cond then { print "privet" return 10} else 20
а поскольку F-RETVAL-LAST как выяснилось работает только для одног окружения.
то либо надо для if ввести свой return, либо различать способы использования if,
либо для функций ввести свой return (pop, exit)

  F-FUNC-EXIT - exit val завершает работу функции.
  да криво косо но пока сойдет. а в целом это тема todo

****************************  

F-RETVAL-LAST
поскольку мы выше сделали что return это возврат из функции,
то из {}-блоков тоже надо как-то что-то возвращать.
идея - возвращаем значение последнего элемента блока.

Тоже не получается. Потому что пишем сверху if () { return } а далее let k:=..
и приехали. Да даже если и print пишем, тоже приехали. Любое приехали.
Видимо.. можно так делать только если 1 оператор. Либо если нет явных return операторов.
Но с учетом что return внутри if-а относится к функции, то его уже и не найти.
Поэтому.. ну сделаем только один. Да и то вопрос..

******************

F-SEQ
оказалось очень ценным таки сделать последовательность шагов.
что вот эти шаги сделались - потом переходим к тем вот следующим.

что значит шаги сделались - да хотя бы что последний оператор выполнился.
ну хотя бы. хотя лучше - что все реакции закончились.

  можно конечно что-то вроде
  apply {} | apply {} 
  но у пайпы подстановка - она сдвигает аргументы вправо.
  хотя было бы красивое.

собсвтенно sequence работает. Надо сделать спец-синтаксис.
Но и в нем хотелось бы чтобы переменные "переходили".
Т.е. если в одном блоке сказали какие-то вещи, то в другом могли их использовать..
Но пока неясно как.

F-SEQ-WAIT
решено сделать не F-SEQ а F-SEQ-WAIT где wait это оператор разбивающий список блоков на 2.

***********************
F-CHILDFUNC-OBJS-RETURN 
чилдрен-функция возвращает список созданных объектов
вдруг пригодится

************************
F-DIRNAME
необходимо в скриптах узнавать папку размещения скрипта
сделана команда __dirname


************************
F-CHANNEL-INIT-CONST
необходимо чтобы входной параметр типа канал - мог реагировать на значения заданные константами.
obj "some" in { input: channel }
some 10
здесь 10 должно быть послано во входной канал input.

F-REST-REACT-ASAP
рест-параметры должны так успевать начать мониториться, 
чтобы успеть поймать сообщения являющиеся реакциями на начальные значения каналов.

*******************
F-NAMED-SPLAT
подстановка словарей в качестве сплат-параметра т.е. все ключи идут в именованные аргументы
foo 1 2 3 a=5 b=7 **some_dict d=44
здесь берутся значения из some_dict и подставляются в параметры.
при этом d=44 имеет приоритет над ними по идее.
и по идее можно несколько таких подстановок, сообразно с приоритетами

параметры должны поступать в именованные. при этом если у цели есть rest-сборщик
то с ним это должно быть состыковано - все что вписывается в обычные параметры идет в обычные,
остальное в рест-сборщик

сделал с ограничениями
- сплат ток один
- ток в конце списка параметров

F-POSITONAL-SPLAT
аналог F-NAMED-SPLAT с сигнатурой:
foo 1 2 3 *arr1 4 5 *arr2 b=7


***********************
F-REST-AUTO-EXTRACT
увидел что всегда когда идет rest то в 100% случаев далее следует extract
из чего следует что extract надо сделать адаптером.ы

F-REACT-ORDER
оказалось важно таки. что реакция запускает функцию которая есть процесс.
потом она получает от нее результат.
так вот возвращать результаты надо в том же порядке, что и запуск реакции.
но мы еще усиляем эту фичу до F-REACT-ORDER-WAIT которая и не начинает
процесса вычисления, пока предыдущий не закончился.
этим мы обеспечиваем некую атомарность реакций. не знаю зачем но интуитивно пригодится.
а так в принципе без разницы - то ли очередь на запуск держать, то ли очередь результатов.

**************************
F-SINGLE-MODULES-DIR
Потребно чтобы все модули необходимые проекту устанавливались в 1 папке modules.
По умолчанию получалось что каждый под-модуль заводит себе свою папку modules.
В итоге выходило дублирование модулей и становилось неудобно их редактировать,
т.к. на практике правка под-модулей выходила во время работы с реальными проектам.
Размещая модули в подмодулей в папке проекта, мы
- избегаем дублирования модулей и необходимости каждый из них вытягивать из гита
- повышаем удобство редактирования подмодулей.

***************************
F-USER-FORM
Возможность создавать формы для компилятора из cl-файла.

***************************
***********
все-таки уже нужны декораторы. в смысле функции которые генерируют сущность (-и)
и которые параметризованы опять же мб функцией или классом. (методом или процессом)

эта потребность чувствуется например при работе с деревьями, когда я хочу добавить поведение сбора детей в массив какой-то. ну т.е. они как метод добавления поведения.
ну стало быть это миксин, поведение, модификатор.

сделано, см F-TRANSFORM

************************
F-ADD-PKG
clon add <адрес-модуля>
он патчит clon.mjs и мб делает clon nest

F-WEB-ICON
иконка по умолчанию для веб-проектов
