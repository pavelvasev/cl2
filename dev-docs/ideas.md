ввести бюрократию.
то есть как живет фича. от идеи до воплощения. и где как документируется.
-------
&external_children должно быть тоже аргументом. и операция их подстановки.
ну т.е. их внешним образом сгенерили и сюда зарядили. а мы их например вмержили в чилдрены.
так должжно быть.

ну я и сделал вроде.. если указан такой параметр то внешние теперь генерятся как функция
и устанавливается.. и можно ее вызывать. хоть много раз.

-----
кстати идея. пусть "объект" может заказывать себе параметр в форме другого "объекта". это будет даже блин проще. 

примеры: 
1
if и говорит - можете мне указать параметр else ))))
2
reaction(in) {=
5 ... drive actuator ...
6 =} deadline (1 ms) {=
7 ... handle a deadline miss ...
8 =}

тут reaction говорит - я ем параметр deadline
2
т..е это значит что если там указали что-то.. в форме полноценного кстати объекта.. то ну пришлите мне этот объект как параметр. ну кстати это вариант - объект прям как параметр. ну а почему нет. это и удобно. да! клево! и вот цепочки можно делать. и даже мб рекурсивно, почему нет..

----
фича заключается в возможности заменять элементы окружения.
но не в лексическом смысле, не в лексической области видимости, а в области видимости развития событий 

 ну т.е. хода по стеку, или в смысле задач - в рамках всех вычисляемых задач исходя из этого запуска.. чтобы они обращаясь к значению - видели новое значение.

 типа это удобство. ну и да, я такого не видал.

 ну вот можно явно это передавать, та же технология как state я сделал. она удобна.

 но каждый раз передавать - вот мы и говорим давайте автоматизируем удобняшку.

 но можно и промежуточный вариант попробовать кстати. что-то на уровне модуля например. ну как вариант. а модуль уже сделать хитрым. 

 ну и его хотя бы передавать не придется. а ссылаться можно. 

 этакий виртуальный модуль

 но он должен вот определяться неявным получается передаваемым параметром.

 ну глянем.
 
https://www.youtube.com/watch?v=l-kctcbLnOQ&list=WL&index=1&t=22s

// идея переопределений.. но изза нашего синтаксиса func name вместо name:func эт не очень красивое стало
with {
  func "print" {: ... :}
} do {

}

-----------
кстати было бы прикольно.. всяко соединять удобно функции..

activate_branch
cleanup_current_parent

и вот сказать что перед activate_branch чтобы вызывалась cleanup_current_parent

мысль - тут бы action задействовать ЛФ-овские.
ну т.е. это передача сообщения как бы.. но выглядит как функция.. т.е. по сути - стройка башенки.

activate_branch: action

activate_branch -> cleanup_current_parent
activate_branch -> {: a b c |
 тут что-то делаем
:}

ну тут с аргументами некая история, с их распаковкой. и с доступом к этой action.
но она на самом деле вот signal..

--------------------
channel некорректное название. он же не канал. лучше уж порт.
но это и не порт LF т.к. последний хранит значения.
поток? ну может..

------
подумать переименовать мб self - плохое слово ибо ыуда, this потому что занято в js.. 

----
ввести состояния.
это часто проскакивает в статьях - что мол вот есть список объектов так разделим его
и будем запускать по частям в зависимости от значения текущего "состояния" в смысле режима.

--------------
ввести понятие потока. поток он как канал но еще имеет промису завершения. 
такое бывает, вот в пайпах unix например.

--------------
сделать уже bind разных объектов.
например 
bind channel func - порождает реакцию
bind func channel - порождает функцию которая пишет результат в channel (и возвращает его).
bind func func - порождает функцию которая выполняет первую а затем вторую.

ну смешно конечно что функция тоже объект синхронизации. а что поделать.

-----
некий символ, который говорит что все последующие операторы в текущем списке это аргументы этого оператора.

например:

apply ~ 
seq ~ 
let a = 5
let b = 7
exec( .... )
exec( .... )

равно
apply {
  seq {
    let a = 5
    let b = 7
    exec( .... )
    exec( .... )
  }
}

-----
переделать схему формирования текстов bundle-2
а именно register_item чтобы регала не только объекты
а и функци и ячейки и вообще все. на self опереться.

-----
bind @channel @func

----
мб переделать bind(src) на обратное - append(tgt).
ввести стандартный интерфейс на вход - submit(value)
и можно на выход - on(fn)..
ну и мб тогда всякие bind стандартизируются
----
для имен вида a_b_c добавлять автоматически алиас вида a-b-c ?
ну так красиво просто..

-----------
вычислительным блокам может быть будет удобно разделить их на стадии и переход между стадиями последовательный когда в стадии все вычисления завершились? (это значит например что все функции верхнего уровня сказали что они .computed)

aaa bbbb
=====
cccc
======
dddd

вот это значит вот это. т.е. это автоматическая вставка seq и seq_block внутри него.

-----
о новой структуре obj-записи
basis, basis_path, module_prefix - хотя формально достаточно одного
items: [] массив
params: словарь
positional_params: как-то бы их отдельно учесть
named_params: ...
subitems: [] массив но мысль - может их убрать в params, они же только там фигурируют? или не только там?..
links: .. - надо ли?

ну короче каша пока. ну хотя бы children на items заменить - что смеяться то.

************************
чето я подумал если скобки не различаются.. то пусть так и будет.
и далее - если объект принимает чилдрены то и ок.
если нет - ну пойдет аргументом как функция.
и даже несколько функций пусть можно будет.

т.е.
combine { x | ... } { y | .... }
какая проблема то.

ну чисто технически.. выявить и понять и совместить.. подумать чутка.
и даже можно будет и так вот:

combine { x | ... } { y | .... } 15 ratio=2

ну то есть я к чему.. раз мы выяснили что ну пусть там процессы запускаются как процессы...
да собственно вот и все.. 

я думаю если с этим разобраться то будет гениально.
ну и далее еще разобраться со скобочками и вычислительным режимом и вторым синтаксисом.

и вот тогда это будет язык так язык.

****************************
сейчас obj::forms.js сразу добавляет текст свой в результат и регистрируется в bundle.
но он мог бы это делать в ленивом режиме по мере требования.
тогда в результат будет добавляться только используемые obj-ы.
аналогично и с func.
но вопрос что делать если их вызывают извне или из платформенных текстов.

****************************
у нас уже есть возможность сделать особые формы на cl-языке.
типа form "let" {: .... :}
и даже чтобы эти формы поедали последующие операторы и команды.

но может быть имеет смысл ввести макросы. это особый вид особых форм,
ну собсвтенно он есть функция готорая что-то выдает и это что-то потом уже в код преобразуется.
в целом макросы похожи на erb который работает тут-же и от параметров компиляции (они параметры и определены к моменту). т.е. например duplicate { ... } 10
есть повторить 10 раз. ну можно их как-то выделять, типа %duplicate или DUPLICATE.

********
мысль - может стоит перейти от модели когда все по умолчанию bindable наоборот, что все static и только некоторое bind-итися?