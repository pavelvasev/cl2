&external_children должно быть тоже аргументом. и операция их подстановки.
ну т.е. их внешним образом сгенерили и сюда зарядили. а мы их например вмержили в чилдрены.
так должжно быть.

ну я и сделал вроде.. если указан такой параметр то внешние теперь генерятся как функция
и устанавливается.. и можно ее вызывать. хоть много раз.

-----
кстати идея. пусть "объект" может заказывать себе параметр в форме другого "объекта". это будет даже блин проще. 

примеры: 
1
if и говорит - можете мне указать параметр else ))))
2
reaction(in) {=
5 ... drive actuator ...
6 =} deadline (1 ms) {=
7 ... handle a deadline miss ...
8 =}

тут reaction говорит - я ем параметр deadline
2
т..е это значит что если там указали что-то.. в форме полноценного кстати объекта.. то ну пришлите мне этот объект как параметр. ну кстати это вариант - объект прям как параметр. ну а почему нет. это и удобно. да! клево! и вот цепочки можно делать. и даже мб рекурсивно, почему нет..

----
фича заключается в возможности заменять элементы окружения.
но не в лексическом смысле, не в лексической области видимости, а в области видимости развития событий 

 ну т.е. хода по стеку, или в смысле задач - в рамках всех вычисляемых задач исходя из этого запуска.. чтобы они обращаясь к значению - видели новое значение.

 типа это удобство. ну и да, я такого не видал.

 ну вот можно явно это передавать, та же технология как state я сделал. она удобна.

 но каждый раз передавать - вот мы и говорим давайте автоматизируем удобняшку.

 но можно и промежуточный вариант попробовать кстати. что-то на уровне модуля например. ну как вариант. а модуль уже сделать хитрым. 

 ну и его хотя бы передавать не придется. а ссылаться можно. 

 этакий виртуальный модуль

 но он должен вот определяться неявным получается передаваемым параметром.

 ну глянем.
 
https://www.youtube.com/watch?v=l-kctcbLnOQ&list=WL&index=1&t=22s

// идея переопределений.. но изза нашего синтаксиса func name вместо name:func эт не очень красивое стало
with {
  func "print" {: ... :}
} do {

}

-----------
кстати было бы прикольно.. всяко соединять удобно функции..

activate_branch
cleanup_current_parent

и вот сказать что перед activate_branch чтобы вызывалась cleanup_current_parent

мысль - тут бы action задействовать ЛФ-овские.
ну т.е. это передача сообщения как бы.. но выглядит как функция.. т.е. по сути - стройка башенки.

activate_branch: action

activate_branch -> cleanup_current_parent
activate_branch -> {: a b c |
 тут что-то делаем
:}

ну тут с аргументами некая история, с их распаковкой. и с доступом к этой action.
но она на самом деле вот signal..

--------------------
channel некорректное название. он же не канал. лучше уж порт.
но это и не порт LF т.к. последний хранит значения.
поток? ну может..

------
подумать переименовать мб self - плохое слово ибо ыуда, this потому что занято в js.. 

----
ввести состояния.
это часто проскакивает в статьях - что мол вот есть список объектов так разделим его
и будем запускать по частям в зависимости от значения текущего "состояния" в смысле режима.