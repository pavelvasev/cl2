ввести бюрократию.
то есть как живет фича. от идеи до воплощения. и где как документируется.
-------
&external_children должно быть тоже аргументом. и операция их подстановки.
ну т.е. их внешним образом сгенерили и сюда зарядили. а мы их например вмержили в чилдрены.
так должжно быть.

ну я и сделал вроде.. если указан такой параметр то внешние теперь генерятся как функция
и устанавливается.. и можно ее вызывать. хоть много раз.

-----
кстати идея. пусть "объект" может заказывать себе параметр в форме другого "объекта". это будет даже блин проще. 

примеры: 
1
if и говорит - можете мне указать параметр else ))))
2
reaction(in) {=
5 ... drive actuator ...
6 =} deadline (1 ms) {=
7 ... handle a deadline miss ...
8 =}

тут reaction говорит - я ем параметр deadline
2
т..е это значит что если там указали что-то.. в форме полноценного кстати объекта.. то ну пришлите мне этот объект как параметр. ну кстати это вариант - объект прям как параметр. ну а почему нет. это и удобно. да! клево! и вот цепочки можно делать. и даже мб рекурсивно, почему нет..

----
фича заключается в возможности заменять элементы окружения.
но не в лексическом смысле, не в лексической области видимости, а в области видимости развития событий 

 ну т.е. хода по стеку, или в смысле задач - в рамках всех вычисляемых задач исходя из этого запуска.. чтобы они обращаясь к значению - видели новое значение.

 типа это удобство. ну и да, я такого не видал.

 ну вот можно явно это передавать, та же технология как state я сделал. она удобна.

 но каждый раз передавать - вот мы и говорим давайте автоматизируем удобняшку.

 но можно и промежуточный вариант попробовать кстати. что-то на уровне модуля например. ну как вариант. а модуль уже сделать хитрым. 

 ну и его хотя бы передавать не придется. а ссылаться можно. 

 этакий виртуальный модуль

 но он должен вот определяться неявным получается передаваемым параметром.

 ну глянем.
 
https://www.youtube.com/watch?v=l-kctcbLnOQ&list=WL&index=1&t=22s

// идея переопределений.. но изза нашего синтаксиса func name вместо name:func эт не очень красивое стало
with {
  func "print" {: ... :}
} do {

}

-----------
кстати было бы прикольно.. всяко соединять удобно функции..

activate_branch
cleanup_current_parent

и вот сказать что перед activate_branch чтобы вызывалась cleanup_current_parent

мысль - тут бы action задействовать ЛФ-овские.
ну т.е. это передача сообщения как бы.. но выглядит как функция.. т.е. по сути - стройка башенки.

activate_branch: action

activate_branch -> cleanup_current_parent
activate_branch -> {: a b c |
 тут что-то делаем
:}

ну тут с аргументами некая история, с их распаковкой. и с доступом к этой action.
но она на самом деле вот signal..

--------------------
channel некорректное название. он же не канал. лучше уж порт.
но это и не порт LF т.к. последний хранит значения.
поток? ну может..

------
подумать переименовать мб self - плохое слово ибо ыуда, this потому что занято в js.. 

----
ввести состояния.
это часто проскакивает в статьях - что мол вот есть список объектов так разделим его
и будем запускать по частям в зависимости от значения текущего "состояния" в смысле режима.

--------------
ввести понятие потока. 
поток он как канал но еще имеет промису завершения. 
такое бывает, вот в пайпах unix например.

да и промисы тоже сделать. мб. даже совместить их с промисами js.

--------------
или хотя бы сделать наши примитивы then-able. По сути это наш subscribe.

--------------
сделать уже bind разных объектов.
например 
bind channel func - порождает реакцию
bind func channel - порождает функцию которая пишет результат в channel (и возвращает его).
bind func func - порождает функцию которая выполняет первую а затем вторую.

ну смешно конечно что функция тоже объект синхронизации. а что поделать.

но это в целом чревато ошибками. уже бывало когда по ошибке в bind подается функция.

-----
некий символ, который говорит что все последующие операторы в текущем списке это аргументы этого оператора.

например:

apply ~ 
seq ~ 
let a = 5
let b = 7
exec( .... )
exec( .... )

равно
apply {
  seq {
    let a = 5
    let b = 7
    exec( .... )
    exec( .... )
  }
}

-----
переделать схему формирования текстов bundle-2
а именно register_item чтобы регала не только объекты
а и функци и ячейки и вообще все. на self опереться.

-----
bind @channel @func

----
мб переделать bind(src) на обратное - append(tgt).
ввести стандартный интерфейс на вход - submit(value)
и можно на выход - on(fn)..
ну и мб тогда всякие bind стандартизируются
----
для имен вида a_b_c добавлять автоматически алиас вида a-b-c ?
ну так красиво просто..

-----------
вычислительным блокам может быть будет удобно разделить их на стадии и переход между стадиями последовательный когда в стадии все вычисления завершились? (это значит например что все функции верхнего уровня сказали что они .computed)

aaa bbbb
=====
cccc
======
dddd

вот это значит вот это. т.е. это автоматическая вставка seq и seq_block внутри него.

***************
в ЛФ у объектов есть Параметры - это значения которые заданы на момент создания объекта и не меняются затем.

параметры ЛФ это как бы параметры конструктора функции которая порождает класс. вот.
поэтому он и не меняется - потому что было время когда он мог быть определен. это норма.

 а его опредлеенность позволяет зато выполнить некоторые вычисления на этапе постройки.
 и это само по себе оч удобно. что не динамически. тут можно разбить построение тогда можно сделать функцией!!!!!! вот это оч хорошо.

 ну это и естественно. Ибо у нас класс это по определению генератор такой функции. Т.е. целевое то это итак функция. Поэтому ничего плохого если этой функции дали ее собственные параметры. Которые она использовала при генерации объекта. idea!

 *************
 надо нам какую-то встроенную визуализацию. 
 быть может не одну.
 причем с фильтрацией, чтобы мелкие подпроцессы не видеть.
=======
-----
о новой структуре obj-записи
basis, basis_path, module_prefix - хотя формально достаточно одного
items: [] массив
params: словарь
positional_params: как-то бы их отдельно учесть
named_params: ...
subitems: [] массив но мысль - может их убрать в params, они же только там фигурируют? или не только там?..
links: .. - надо ли?

ну короче каша пока. ну хотя бы children на items заменить - что смеяться то.

************************
чето я подумал если скобки не различаются.. то пусть так и будет.
и далее - если объект принимает чилдрены то и ок.
если нет - ну пойдет аргументом как функция.
и даже несколько функций пусть можно будет.

т.е.
combine { x | ... } { y | .... }
какая проблема то.

ну чисто технически.. выявить и понять и совместить.. подумать чутка.
и даже можно будет и так вот:

combine { x | ... } { y | .... } 15 ratio=2

ну то есть я к чему.. раз мы выяснили что ну пусть там процессы запускаются как процессы...
да собственно вот и все.. 

я думаю если с этим разобраться то будет гениально.
ну и далее еще разобраться со скобочками и вычислительным режимом и вторым синтаксисом.

и вот тогда это будет язык так язык.

****************************
сейчас obj::forms.js сразу добавляет текст свой в результат и регистрируется в bundle.
но он мог бы это делать в ленивом режиме по мере требования.
тогда в результат будет добавляться только используемые obj-ы.
аналогично и с func.
но вопрос что делать если их вызывают извне или из платформенных текстов.

****************************
у нас уже есть возможность сделать особые формы на cl-языке.
типа form "let" {: .... :}
и даже чтобы эти формы поедали последующие операторы и команды.

но может быть имеет смысл ввести макросы. это особый вид особых форм,
ну собсвтенно он есть функция готорая что-то выдает и это что-то потом уже в код преобразуется.
в целом макросы похожи на erb который работает тут-же и от параметров компиляции (они параметры и определены к моменту). т.е. например duplicate { ... } 10
есть повторить 10 раз. ну можно их как-то выделять, типа %duplicate или DUPLICATE.

********
мысль - может стоит перейти от модели когда все по умолчанию bindable наоборот, что все static и только некоторое bind-итися?
********
вот есть проблема несогласованного присвоения аргументов:
print @x (cos (@x+1))
при изменении x в принт уйдет сразу сигнал про сам x а через несколько тактоов про cos-часть.
и будет написано два раза.

идея - когда нужна согласованность применения, выносить ее в синхронизируемую часть типа функция (задача)
которая возвращает сразу набор значений (в форме ли позиционной пачки, или комбинации из позиционных и словарных.. кстати что это за структура тогда которая и позиционное и словарное? просто такой пакет из массива и словаря?). что-то вроде:

`print *(apply {x | list @x (cos (@x+1)) } @x)`

ну т.е. формально
args := apply { list @x (cos (@x+1)) }
print (get @args 0) (get @args 1)

это все попытка на самом деле получше разобраться с плоскостью времени.
с которой у нас пока только такие решения
- что каналы распространяются моментально, а ячейки с задержкой+поеданием (остается последнее значение)
- что реакции с задержкой выполняются, но без поедания (т.е. если дубликаты то ок).

p.s. частично сделано, см F-COHERENT-MIND

*********************
сделать функцию которая запускает передает объекту параметры командной строки.
т.о. "программа" это объект (ну точнее процесс).

*********************

сделать разбивку стадий в задаче по символу ============ или еще какому-то.
и типа это означает.. ну например что последний оператор завершил работу, или все операторы блока завершили работу - переходим к этому блоку. что-то такое.

ну это выглядит вполне естественно..
print 1
=================
print 2

можно даже по явной команде..
print 1
pass 10
================ x
print @x

хотя выглядит излишним.

************************

аксессоры к ячейкам, вида @obj[elem][name]. Ну это как get.

Но и get должен у нас быть хитрым. Если то к чему он обращается это ячейка, то он должен на нее подписаться по уму. И выдавать значения...

**************************
корошо бы делать полный bundle. 
чтобы генерируемый js-файл был абсолютно самодостаточен (зависел ток от встроенных нода-пакетов) и его можно было таскать всюду без зависимостей.
хоть как утилиту командной строки, хоть как файл для веба.
===========================
кстати у нас еще суб-платформы есть - нода командная строка, веб, электрон.
электрон кстати очень даже может оказаться ничего. хоть приложения делай.

хотя приложениям лучше c++ и imgui или вроде того - быстрее будет работать
и ничего лишнего не тянуть.

*******************************
может быть модулям и не обязательно чтобы был init.js..
тогда мы в modules сможем указывать любые гит-пакеты и оно нам будет качать.
*******************************
было бы неплохо subdir указывать для git-источников 
и тогда это означает что модуль сидит в папке. 
тогда гит-проект может содержать много модулей.

хотя это второстепенно т.к. ну ссылаться на подмодули
вроде можно напрямую.
********************************

все-таки компилятор удобнее если был бы в форме make_code(obj,state,objs) => strings, objs
т.е. так make_code получал бы полное управление а отдавал бы остаток - что надо еще до-генерировать.
но тогда меняется логика вызова one_obj2js_sp (на while + не факт что каждая запись даст объект, но может) но это можно сделать. ну или переделать на вызов для серии объектов, с каллбеками после каждой итерации.

в частности при реализации F-SEQ и F-SEQ-WAIT этого очень не хватило.

---------------------------------
надо как-то активнее применять кодо-генерацию.
- в момент компиляции
- в момент создания "объекта" на основе параметров (они определены к моменту старта)
  т.е генерировать еще до момента когда объект "заработал".
  в идеале чтобы можно было бы генерировать и сами определения объектов.
ну потому что пока мы это не делаем мы имеем просто статичное поле..
хороший пример - erb и прочие шаблонизаторы. когнитивная мощь!  

*****************
F-RUN можно сделать run программы и получать что она там вернула в глобальном смысле.
именно как объект. на основе передач сообщений между нодами например.
должно быть удобно. пример: https://www.w3.org/2019/11/dms/#run-statement

*****************
F-CLON-CMD
а еще такая идея что clon а все что дальше это clon-команда )))

clon add 1 2 3
clon sin 10

clon run

и т.д. и т.п.. ну все в строчки понятно дело кроме чисел.

слон загружается, загружает свой какой-то собственный рантайм, и поехали )))

но хорошо бы сделать и несколько операций?

*****************

такой пакет который создает словарь вокруг файловой системы.
обращение к ключам словаря это сообразно чтение из файловой системы
и запись в неё. причем словарю можно задать режим доступа - только чтение,
запись, запись без перезаписи.

ну это мб и не словарь а какое-то объект доступа и функции работы с ним..

*****************
хочется сделать веб-сервер. ну какой-то такой, удобный для пользования.

или мб автоматом проксировать объекты в веб. чтобы можно было к ним доступ
получать из других объектов.

и отдельно-параллельно - чтобы веб-сервер автоматом компилирующий cl файлы.
а то каждый раз перекомпилировать уже надоело.

*****************
а зачем писать import если у нас итак все импорты перечислены в clon.mjs?
хм..

*****************
задача для дом-модуля.
вводится чекбокс. 
- и если он нажат то какой-то элемент видимый, иначе невидимый
- и если он нажат то появляется (рендерится) кнопка, иначе исчезает.

вопросы: 
- как делать чекбокс? dom.element "input" type="checkbox"
тут надо все rest-штуки прокинуть в дом получается.
- иф создает под-объекты во вложенном режиме.. в себе внутрях..
что он возвращает и как это подключить к дереву?

вторая задача для дом-модуля.
- вводится слайдер
- по числу заданному слайдером генерируется див-квадратики красивые.
***************

в веб-разработке если ошибка компиляции то выводить ее на страницу!
можно писать ошибку в файл а страница пусть подгружает.

***************
в веб-разработке почему-то перекомпиляция ток если главный модуль меняется а не либа..
а ну нода 19.1+ смогет.

***************
мб таки сделать реакции на уровне рантайма. и тогда create_reaction и можно тогда в платф языке делать какие-то объекты и функции и т.п.

кстати неплохая идея полностью реализовывать объекты в платф. языке.

***************
таки напрашиваются вещи типа state и param в определениях объектов-процессов.
* param это неизменяемый параметр, им зато может пользоваться конструктор и вообще можно генерировать - эт хорошо. но кстати а как в выражениях его учесть - неясно..
* state ну это обычная переменная, не канал и т.п. в принципе можно получается обходиться канралами-портами и state и из них слепить что угодно, например ячейки или потоки.

это кстати так-то выглядит неплохо. ну и на уровне js мы именно так и делаем. но если сделать на уровне слона то тогда вроде как портировать будещ проще на другие платформы.

******************
named_rest может всегда делать автоматом extract?
ну потому что.. по факту я всегда этим пользуюсь, в 100% случаев.

ну можно провернуть такой трюк что **named_rest: cell
чтобы совместимость сохранить. ну а можно и не сохранять а просто сделать разово.

****************
- генераторы функций, объектов - т.е. код получает управление и формирует функцию или объект.
- параметры оных генераторов
- модификаторы которые аля питонские @декораторы
- они же макросы..

- убрать тотальное дерево, накладные расходы а не используется

- надо уже навести бюрократию.
идея - фича - микропроект - как завершается.
ну и помним что идеал это фича в плагине.

******************
+ ввести бюрократию!
- идея фичи =>
- более формальное описание идеи, потребности, реализации =>
- реализация и фиксация.

******************
в дом- и threejs вместо is_element сделать output_object или output_dom, output_node
и по этому признаку и собирать детей.

******************
чето муть какая-то с моей моделью. передали ключ name=value но value ссылка неназначенная ячейка и от этого тормозится вся сборка named-rest..