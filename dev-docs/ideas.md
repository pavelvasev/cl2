ввести бюрократию.
то есть как живет фича. от идеи до воплощения. и где как документируется.
-------
&external_children должно быть тоже аргументом. и операция их подстановки.
ну т.е. их внешним образом сгенерили и сюда зарядили. а мы их например вмержили в чилдрены.
так должжно быть.

ну я и сделал вроде.. если указан такой параметр то внешние теперь генерятся как функция
и устанавливается.. и можно ее вызывать. хоть много раз.

-----
кстати идея. пусть "объект" может заказывать себе параметр в форме другого "объекта". это будет даже блин проще. 

примеры: 
1
if и говорит - можете мне указать параметр else ))))
2
reaction(in) {=
5 ... drive actuator ...
6 =} deadline (1 ms) {=
7 ... handle a deadline miss ...
8 =}

тут reaction говорит - я ем параметр deadline
2
т..е это значит что если там указали что-то.. в форме полноценного кстати объекта.. то ну пришлите мне этот объект как параметр. ну кстати это вариант - объект прям как параметр. ну а почему нет. это и удобно. да! клево! и вот цепочки можно делать. и даже мб рекурсивно, почему нет..

----
фича заключается в возможности заменять элементы окружения.
но не в лексическом смысле, не в лексической области видимости, а в области видимости развития событий 

 ну т.е. хода по стеку, или в смысле задач - в рамках всех вычисляемых задач исходя из этого запуска.. чтобы они обращаясь к значению - видели новое значение.

 типа это удобство. ну и да, я такого не видал.

 ну вот можно явно это передавать, та же технология как state я сделал. она удобна.

 но каждый раз передавать - вот мы и говорим давайте автоматизируем удобняшку.

 но можно и промежуточный вариант попробовать кстати. что-то на уровне модуля например. ну как вариант. а модуль уже сделать хитрым. 

 ну и его хотя бы передавать не придется. а ссылаться можно. 

 этакий виртуальный модуль

 но он должен вот определяться неявным получается передаваемым параметром.

 ну глянем.
 
https://www.youtube.com/watch?v=l-kctcbLnOQ&list=WL&index=1&t=22s

// идея переопределений.. но изза нашего синтаксиса func name вместо name:func эт не очень красивое стало
with {
  func "print" {: ... :}
} do {

}

-----------
кстати было бы прикольно.. всяко соединять удобно функции..

activate_branch
cleanup_current_parent

и вот сказать что перед activate_branch чтобы вызывалась cleanup_current_parent

мысль - тут бы action задействовать ЛФ-овские.
ну т.е. это передача сообщения как бы.. но выглядит как функция.. т.е. по сути - стройка башенки.

activate_branch: action

activate_branch -> cleanup_current_parent
activate_branch -> {: a b c |
 тут что-то делаем
:}

ну тут с аргументами некая история, с их распаковкой. и с доступом к этой action.
но она на самом деле вот signal..

--------------------
channel некорректное название. он же не канал. лучше уж порт.
но это и не порт LF т.к. последний хранит значения.
поток? ну может..

------
подумать переименовать мб self - плохое слово ибо ыуда, this потому что занято в js.. 

----
ввести состояния.
это часто проскакивает в статьях - что мол вот есть список объектов так разделим его
и будем запускать по частям в зависимости от значения текущего "состояния" в смысле режима.

--------------
ввести понятие потока. поток он как канал но еще имеет промису завершения. 
такое бывает, вот в пайпах unix например.

--------------
сделать уже bind разных объектов.
например 
bind channel func - порождает реакцию
bind func channel - порождает функцию которая пишет результат в channel (и возвращает его).
bind func func - порождает функцию которая выполняет первую а затем вторую.

ну смешно конечно что функция тоже объект синхронизации. а что поделать.

-----
некий символ, который говорит что все последующие операторы в текущем списке это аргументы этого оператора.

например:

apply ~ 
seq ~ 
let a = 5
let b = 7
exec( .... )
exec( .... )

равно
apply {
  seq {
    let a = 5
    let b = 7
    exec( .... )
    exec( .... )
  }
}

-----
переделать схему формирования текстов bundle-2
а именно register_item чтобы регала не только объекты
а и функци и ячейки и вообще все. на self опереться.

-----
bind @channel @func

----
мб переделать bind(src) на обратное - append(tgt).
ввести стандартный интерфейс на вход - submit(value)
и можно на выход - on(fn)..
ну и мб тогда всякие bind стандартизируются
----
для имен вида a_b_c добавлять автоматически алиас вида a-b-c ?
ну так красиво просто..

-----------
вычислительным блокам может быть будет удобно разделить их на стадии и переход между стадиями последовательный когда в стадии все вычисления завершились? (это значит например что все функции верхнего уровня сказали что они .computed)

aaa bbbb
=====
cccc
======
dddd

вот это значит вот это. т.е. это автоматическая вставка seq и seq_block внутри него.

***************
в ЛФ у объектов есть Параметры - это значения которые заданы на момент создания объекта и не меняются затем.

параметры ЛФ это как бы параметры конструктора функции которая порождает класс. вот.
поэтому он и не меняется - потому что было время когда он мог быть определен. это норма.

 а его опредлеенность позволяет зато выполнить некоторые вычисления на этапе постройки.
 и это само по себе оч удобно. что не динамически. тут можно разбить построение тогда можно сделать функцией!!!!!! вот это оч хорошо.

 ну это и естественно. Ибо у нас класс это по определению генератор такой функции. Т.е. целевое то это итак функция. Поэтому ничего плохого если этой функции дали ее собственные параметры. Которые она использовала при генерации объекта. idea!

 *************
 надо нам какую-то встроенную визуализацию. 
 быть может не одну.
 причем с фильтрацией, чтобы мелкие подпроцессы не видеть.
