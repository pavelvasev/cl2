DD-OBJ-PARENT-BEHALF
Объекты сами отвечают за свое прицепляние в родительское дерево. 
Для этого им передается state.struc_parent_id.
Т.е. они сами говорят [state.struc_parent_id].append( obj ). 
Потому что а) так проще чилдренов генерить изнутри объекта и снаружи,
а главное - не все "объекты синтаксические" будут объектами дерева, например let не будет.

update там надо иметь 2 родителя. 1 для формирования исходящих ссылок, struc_parent_id, а второй для подключения к дереву, tree_parent_id. Второго может и не быть, если например не древовидного вида вещь.

---
F-RAW-COMPUTING
убрал таски. итого в вычислительном режиме.. все как раньше.

процессы - работают именно как процессы, с обновлениями по данным.
функции - ну расчет что разово сработают и не более того.

причина этого решения - что в функциональном режиме мне надо было запустить подпроцесс операционной системы через os.spawn, а оказалось это невозможно, именно из-за автоматического превращения процессов в задачи которые ожидают получения output.

поэтому процессы в режиме задач остаются процессами. в конце концов в обычных языках обычное дело, когда обращение к чему-то создает процесс и возвращает его.

	в этом смысле, быть может будет интерес ввести именно потоки аля stream которые имеют конец.
	и тогда - закончившийся поток активирует задачу.
	хотя с другой стороны интереснее на каждый писк реагировать по запуску задач.
	но посмотрим.

другим вариантом было бы явное создание процессов, в духе start { os.spawn }
это как в объектном режиме есть apply который переводит функции в пр-во процессов,
так и тут - перевод процессов в пр-во задач (которые у нас и представляют функции в модели вычисления задач).

-----
описание функций в формах {: .. :} и { ... } сделано так что они дают значение параметра.
которое затем можно использовать инлайн. 
это приводит к уменьшению кол-ва скобок, да и программа проще становится.
Это идея Миши.

======
F-EMBED-RUNTIME
cl2.js внедряется в целевые программы, а иначе npx clon-lang не работает (не находит модуль).
+ надо бы и платформенное также (web.js) добавлять
+ надо предусмотреть вариант управления этим, в частности вообще не включать ни рантайм ни default и вообще объединять разные пакеты в один js-модуль. т.е. все более гибко аля webpack.
итого это напрашивается на управляемый конвейер (из настроек проекта) уровня плагина compile.
------------

конфигурация проекта в clon.mjs а не в init.js
потому что нода отказывается выполнять import("init.js") если нет package.json файла с директивой type:module. Странные они. 

кстати если это было бы clon.cl или config.cl то такой проблемы бы не было.
а почему оно до сих пор не такое мне не ясно.. что-то я соображал на этот счет.
а ну что внешними утилитами тогда не прочитать будет. хм. но можно же вызывать тогда clon и чтобы он в json выдавал какие-то переменные.

*******************
важная идея. хорошо бы слон-проектам интегрироваться в имеющиеся среды.
например автоматизация настройки серверов - вот есть апи,
а мы на слон пишем программы сводящиеся к этому апи,
и компоненты реализующие эти апи. т.е. можем заменить если что слоны.
а то была история с запуском - куча понаделано и не заменишь.

*******************
вот то что я перенес все чайлд-вещи обзоначил функциями (в режиме children_mode)
привело к тому что получается любой объект в скобках {} становится неадресуемый извне.

итого адресовать можно только свой уровень или выше. хм.

просто вмещать в {} оказывается надо например по странной причине - чекбокс внутрь лейбла посадить например. а и все, чекбокс снаружи недоступен..

но может быть это и к лучшему. т.е. внутренние вещи имеют доступ наружу. а нуржние во внутрь - не имеют. хоть это и декларативный документ. ну, вот такое дизайн случайно получился.
зато у нас все блоки {} являются функциями и это вроде как удобно.
и передавать и переадресовывать и вообще. но надо поточнее разобраться с причинами почему я так сделал.

************************
реакция должна что-то возвращать получается. потому что выяснилось что нам надо соблюдать порядок при возврате значений из реакций, на это опираются.
а чтобы его соблюдать - надо понимать когда работа запущенного реакцией процесса завершилась.
в будущем можно будет наверное отслеживать шедулед-движения и возвращать неопределенность когда они закончились.
************************
F-TREE дало много решений принятых. Например что у каждого {}-процесса создаётся теперь контекст func_self и именно он возвращается в качестве результата работы {}-блока. 
И это процесс который имеет 2 вещи - output для обычных значений и .tree для накопления вложенных в процесс подобъектов.
Обычные реакции смотрят на .output.
А apply_children добавляет полученную func_self как лифт в себя, а себя - в родительский блок тоже как лифт. И таким образом объекты определеныне в {} добираются до родителя.

************************
F-TREE деревья сделаны как миксины внутрь объектов, которые мы хотим видеть древовидными.
это по опыту complang там было внешнее и я намучился писать все время префикс obj.ns.xxx 
да и сейчас тяжко было понимать, кто там объект а кто узел дерева. а очень удоблно когда все одно все едино (хоть это и странно).

************************
Как же всетаки хорошо что у нас нет методов подписки на событие как все делают on('event-type'). Как же хорошо что мы поняли что это ерунда и глупость так делать.
И как же хорошо: obj.event_type.on( .... ) 
- и ясно и понятно, вот объект, а вот у него канал такой-то. и вот можете с ним работать.
- передать канал можно куда-нибудь по ссылке.
- и заодно проверка рантайм средой что такое "событие" вообще есть.
- и ясность, что вот это не "тип события" а вполне себе отдельный канал.
ну они мыслят видимо что объект как бы сам и является каналом, а внутри него разные "типы событий" путешествуют. но это странно же.. и никак кстати не используется, а только по смыслу как разные каналы используется.