DD-OBJ-PARENT-BEHALF
Объекты сами отвечают за свое прицепляние в родительское дерево. 
Для этого им передается state.struc_parent_id.
Т.е. они сами говорят [state.struc_parent_id].append( obj ). 
Потому что а) так проще чилдренов генерить изнутри объекта и снаружи,
а главное - не все "объекты синтаксические" будут объектами дерева, например let не будет.

update там надо иметь 2 родителя. 1 для формирования исходящих ссылок, struc_parent_id, а второй для подключения к дереву, tree_parent_id. Второго может и не быть, если например не древовидного вида вещь.

---
F-RAW-COMPUTING
убрал таски. итого в вычислительном режиме.. все как раньше.

процессы - работают именно как процессы, с обновлениями по данным.
функции - ну расчет что разово сработают и не более того.

причина этого решения - что в функциональном режиме мне надо было запустить подпроцесс операционной системы через os.spawn, а оказалось это невозможно, именно из-за автоматического превращения процессов в задачи которые ожидают получения output.

поэтому процессы в режиме задач остаются процессами. в конце концов в обычных языках обычное дело, когда обращение к чему-то создает процесс и возвращает его.

	в этом смысле, быть может будет интерес ввести именно потоки аля stream которые имеют конец.
	и тогда - закончившийся поток активирует задачу.
	хотя с другой стороны интереснее на каждый писк реагировать по запуску задач.
	но посмотрим.

другим вариантом было бы явное создание процессов, в духе start { os.spawn }
это как в объектном режиме есть apply который переводит функции в пр-во процессов,
так и тут - перевод процессов в пр-во задач (которые у нас и представляют функции в модели вычисления задач).

-----
описание функций в формах {: .. :} и {{ ... }} сделано так что они дают значение параметра.
которое затем можно использовать инлайн. 
это приводит к уменьшению кол-ва скобок, да и программа проще становится.
Это идея Миши.

======
F-EMBED-RUNTIME
cl2.js внедряется в целевые программы а иначе npx clon-lang не работает (не находит модуль).
+ надо бы и платформенное также (web.js) добавлять
+ надо предусмотреть вариант управления этим, в частности вообще не включать ни рантайм ни default и вообще объединять разные пакеты в один js-модуль. т.е. все более гибко аля webpack.
итого это напрашивается на управляемый конвейер (из настроек проекта) уровня плагина compile.
------------

конфигурация проекта в clon.mjs а не в init.js
потому что нода отказывается выполнять import("init.js") если нет package.json файла с директивой type:module. Странные они. 

кстати если это было бы clon.cl или config.cl то такой проблемы бы не было.
а почему оно до сих пор не такое мне не ясно.. что-то я соображал на этот счет.
а ну что внешними утилитами тогда не прочитать будет. хм. но можно же вызывать тогда clon и чтобы он в json выдавал какие-то переменные.

*******************
важная идея. хорошо бы слон-проектам интегрироваться в имеющиеся среды.
например автоматизация настройки серверов - вот есть апи,
а мы на слон пишем программы сводящиеся к этому апи,
и компоненты реализующие эти апи. т.е. можем заменить если что слоны.
а то была история с запуском - куча понаделано и не заменишь.

*******************
вот то что я перенес все чайлд-вещи обзоначил функциями (в режиме children_mode)
привело к тому что получается любой объект в скобках {} становится неадресуемый извне.

итого адресовать можно только свой уровень или выше. хм.

просто вмещать в {} оказывается надо например по странной причине - чекбокс внутрь лейбла посадить например. а и все, чекбокс снаружи недоступен..