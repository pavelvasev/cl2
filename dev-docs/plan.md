# F-REST-SUBST
сделать rest-подстановку при передаче позиционных аргументов: 
`print *@arr`

-----
F-DESTROY-EXPR
Удаление объекта долно приводить к удалению и его под-выражений (они идут в attached-дереве).
a: foo (some (expr))
... a.destroy() - должно удалить и some и expr.

-------
- таки сделать установщик пакетов. хотя спорно, надо ли. может быть проще заюзать нодовский.
но попробуем для интересу.

- таки сделать что не надо func указывать. а именно пишем везде {: :} и это есть переход в вычислительный режим. хотя чем он щас отличается мне не очень ясно ))))
но в целом - просто уйди от анонимных func типа {= =} и {: :} это и есть функ.

- подстановка параметров *rest и **named_rest а также параметр named_rest**
- dict alfa=.. beta=.. создает "словарь"

- состояния и переключения между ними. где-то я читал что это удобно. ну и типа вот процесс и он перключается между состояниями и его куски активируются и деактивируются. в целом это как if но синтаксически красивее.

- попробовать bind с разными параметрами. так-то интересно.

*
reduce_events научить работать с ко-функциями. и мб как следствие react научить буферизации.

**********
все-таки нужна последовательность действий тоже. сначала сделай это, потом сделай то.
например при взаимодействии с внешними системами.
мысли:
* seq { ... } и внутренние вещи тогда будут последовательно
* {~ ... } и типа ~ задала нам флаг что последовательное исполнение
* оператор ===== и он типа дожидается чтобы было сделано все что сверху, а затем активирует следующий блок.
можно нисколько таких, т..е
print 1 === print 2 === print 3
ну наверное не === а ~~  или другое какое-то
print 1 ~~ print 2 ~~ print 3

в принципе пока можно обходиться так:
apply { return (print 1) } | apply { return (print 2) }
если сделать автоматический ретерн для окружений из 1 оператора,
а apply заменить на символ, то будет
% { print 1} | % { print 2 } нет уж лучше символа не надо )))
*******
Задержки на bind нужны таки. С ними удобно.
итого bind @src @tgt delay=T
причем T это логическое время.

***************
как-то сделать when-any но такое чтобы возвращать все текущие значения. (даже если нету)
это собственно режим работы реакций LF кстати.
понадобилось при реализации dom.cl

****************
ну короче да, нужна новая модель работы с детьми.

ну и не факт что сейчас. а в целом. а то сейчас излишне все.

вроде как достаточно что children-func (а у нас через нее теперь все только подается)
вернет список созданных объектов. из которых надо вычленить то что может быть чилдреном
т.е. наследник скажем item. а дальше уже прикладная логика выделяет объекты которые
нужны прям. (для дома - домовские объекты, для 3д - тридешные и т.п.).

сейчас же.. оно все аппендится при вызове функции. непонятно, надо ли это.
и там лишний аргумент возникает у функции и он так-то бесит.

ну а может достаточно создать контекстный объект (щас это func_self) и в него цеплять.
и возвращать его же. ну короче надо на свежую голову это все подумать.

ну и это ускорит нам работу т.к. чилдрены в целом редко нужны.

*****************
F-CLON-CMD-ENV
ну то есть - некие вещи добавляются в state или там env транслятора.
в форме функций.
ну и он передает управление таковой функции.
а всякое add_command это явно лишнее - надстройка же.

т.е. надо сделать чтобы клон-команды можно было на клон-языке указывать.
тогда всякие плагины.. пишут функции на клоне и это и будет клон-команды.

ну либо по мотивам питона - команда это загрузка модуля
python -m SimpleHTTPServer
npx packagename и в частности npx url
а еще есть npm create packagename... но у нас нет пока реестра.

т.е. clon cmd args
это на самом деле загрузка модуля cmd и передача ему управления.
это кстати даже дешевле будет - всех загружать не надо.
ммм. ну и можно точку входа придумать, типа func "clon-call"

но и идея что заполняем окружение функциями так-то красивая.
но и дальше - идея о том что не clon init-web а clon add web; clon web
...

*****************
таки подумать о способе вызова функций. сейчас они через объект-каллер делаются (по сути реакцию). и фибоначчи от 17 считается несколько секунд!
*****************
разбор операторов и callstyle-вызовов

func "fib" { n |
  // print "fib called" @n
  if (@n > 1) {
    //return ((fib (@n - 1) + (fib (@n - 2))))
    // вот это распознается криво.. как 3 несвязанных операции
    res := fib( @n-1 ) + fib( @n-2 )
    // и вот это тоже
    // res := 10 + (fib (@n-2))
    // а вот это распознается
    // res := (fib (@n-1)) + (fib (@n-2))
    // и вот это норм
    //res := plus( fib( @n-1 ), fib( @n-2 ) )
    exit @res
  } else { exit @n }
}

x := fib 10
print "x=" @x

**********************
все-таки os.spawn должна давать на выход именно поток а не просто канал-порт.
чтобы поток мог закрыться.
тогда - будет работать wait ===== ловя такие закрытия, даже если не было записей в output.

***********

* плохо проработаны арифметические операторы.
	* кстати идея как сделаны они в lua - там метатаблицы и оператор к ним обращается и получается разные сущности можно складывать вычитать и прочее.
* плохо проработана работа с детьми.

* map-parallel уже надо. а то тесты долго работают.

******************
надо нормализовать узлы которые выдает pegjs.
- сейчас там много лишнего.
- в подвыражениях даются ссылки на features_list а 
это неправильно надо именно expression значение да и все.

предлагается что-то вроде:
basis: name | array
pos_params: array
named_params: dict
и всё...

ну или не named_params а просто params.
- удобно что кол-во позиционных параметров известно через pos_params.length и удобно добавлять (unshift или push)
- детей мы решили хранить как значения параметров..

ну и вот такие получается у нас структуры.

ну или 
params и params._pos например.
или
params + pos_param + named_params.
где в params все - а в других только то что про них. но неудобно добавлять - надо в два массива.. нет уж, лучше в одном пусть месте будут.

ну либо оставить как было, т.е. все в params, а дополнительно count - кол-во параметров.. но тогда unshift не сделаешь. ну да.
=======

Удалить next_obj_param фичу

**********
таки научить react реагировать в режиме any на перечисленные аргументы.
т.о. он форма.

и уже мб ввести время. выяснено, что если вводить время то мы получается делаем честный автомат, а реакции становятся правилами по разбору его слова. при этом само входное слово становится длинным - оно есть комбинация всех входных каналов(=слов).

*******
нужны именованные аргументы для функций
func "map" {: arr batch_size f| ... :}
map @data batch_size=10 f

для этого надо научить generate_func_caller использовать аргументы по-нормальному.

-----------
bind (dom.event @btsearch "click") @do_search

-----------
нужно что-то типа action. или подумать как такое делать своими средсвтами.

*****
на самом деле уже пора проверять что ссылки существуют.
т.е. пишем alfa=@some.foo и надо выявлять что эта some.foo есть.
источики у нее:
- ячейки и каналы
- параметры
- импортированные окружения
- созданные объекты
- но как проверять вещи вида @objid.objcell ?
F-TODO-CHECK-NAMESPACES

update подтверждаю а то ждал @k.exit_code а ее неиту..
**********************
В следующем примере Qq никогда не напечатается.
Потому что k1 никогда не выдаст ничего наружу.. т.к. inherit не пишет в каналы
print "starting web dev"
import os="std/os.cl"

k1: os.spawn "clon" "compile" stdio="inherit"
print "compiled" @k1.exitcode
================
print "Qq"

===================
но самое главное. вот если слон будет провоцировать создавать программы с ортогональным наполнением фичами, вот это будет его мега-фишка.