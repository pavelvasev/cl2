# F-REST-SUBST
сделать rest-подстановку при передаче позиционных аргументов: 
`print *@arr`

----
F-PIPES
F-PIPES-INPUT-ARG
pipe-ы вернуть
при этом проверить что идет позиционная подстановка input-аргумента.
т.е. если сигнатура foo (input alfa beta) то тогда
some | foo alfa beta
а input подставляется пайпой.

-----
F-DESTROY-EXPR
Удаление объекта долно приводить к удалению и его под-выражений (они идут в attached-дереве).
a: foo (some (expr))
... a.destroy() - должно удалить и some и expr.

-------
- таки сделать установщик пакетов. хотя спорно, надо ли. может быть проще заюзать нодовский.
но попробуем для интересу.

- таки сделать что не надо func указывать. а именно пишем везде {: :} и это есть переход в вычислительный режим. хотя чем он щас отличается мне не очень ясно ))))
но в целом - просто уйди от анонимных func типа {= =} и {: :} это и есть функ.

- подстановка параметров *rest и **named_rest а также параметр named_rest**
- dict alfa=.. beta=.. создает "словарь"

- состояния и переключения между ними. где-то я читал что это удобно. ну и типа вот процесс и он перключается между состояниями и его куски активируются и деактивируются. в целом это как if но синтаксически красивее.

- попробовать bind с разными параметрами. так-то интересно.

*