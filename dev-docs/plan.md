# F-REST-SUBST
сделать rest-подстановку при передаче позиционных аргументов: 
`print *@arr`

-----
F-DESTROY-EXPR
Удаление объекта долно приводить к удалению и его под-выражений (они идут в attached-дереве).
a: foo (some (expr))
... a.destroy() - должно удалить и some и expr.

-------
- таки сделать установщик пакетов. хотя спорно, надо ли. может быть проще заюзать нодовский.
но попробуем для интересу.

- таки сделать что не надо func указывать. а именно пишем везде {: :} и это есть переход в вычислительный режим. хотя чем он щас отличается мне не очень ясно ))))
но в целом - просто уйди от анонимных func типа {= =} и {: :} это и есть функ.

- подстановка параметров *rest и **named_rest а также параметр named_rest**
- dict alfa=.. beta=.. создает "словарь"

- состояния и переключения между ними. где-то я читал что это удобно. ну и типа вот процесс и он перключается между состояниями и его куски активируются и деактивируются. в целом это как if но синтаксически красивее.

- попробовать bind с разными параметрами. так-то интересно.

*
reduce_events научить работать с ко-функциями. и мб как следствие react научить буферизации.

**********
все-таки нужна последовательность действий тоже. сначала сделай это, потом сделай то.
например при взаимодействии с внешними системами.
мысли:
* seq { ... } и внутренние вещи тогда будут последовательно
* {~ ... } и типа ~ задала нам флаг что последовательное исполнение
* оператор ===== и он типа дожидается чтобы было сделано все что сверху, а затем активирует следующий блок.
можно нисколько таких, т..е
print 1 === print 2 === print 3
ну наверное не === а ~~  или другое какое-то
print 1 ~~ print 2 ~~ print 3

в принципе пока можно обходиться так:
apply { return (print 1) } | apply { return (print 2) }
если сделать автоматический ретерн для окружений из 1 оператора,
а apply заменить на символ, то будет
% { print 1} | % { print 2 } нет уж лучше символа не надо )))
*******
Задержки на bind нужны таки. С ними удобно.
итого bind @src @tgt delay=T
причем T это логическое время.

***************
как-то сделать when-any но такое чтобы возвращать все текущие значения. (даже если нету)
это собственно режим работы реакций LF кстати.
понадобилось при реализации dom.cl

****************
ну короче да, нужна новая модель работы с детьми.

ну и не факт что сейчас. а в целом. а то сейчас излишне все.

вроде как достаточно что children-func (а у нас через нее теперь все только подается)
вернет список созданных объектов. из которых надо вычленить то что может быть чилдреном
т.е. наследник скажем item. а дальше уже прикладная логика выделяет объекты которые
нужны прям. (для дома - домовские объекты, для 3д - тридешные и т.п.).

сейчас же.. оно все аппендится при вызове функции. непонятно, надо ли это.
и там лишний аргумент возникает у функции и он так-то бесит.

ну а может достаточно создать контекстный объект (щас это func_self) и в него цеплять.
и возвращать его же. ну короче надо на свежую голову это все подумать.

ну и это ускорит нам работу т.к. чилдрены в целом редко нужны.

*****************
F-CLON-CMD-ENV
ну то есть - некие вещи добавляются в state или там env транслятора.
в форме функций.
ну и он передает управление таковой функции.
а всякое add_command это явно лишнее - надстройка же.

т.е. надо сделать чтобы клон-команды можно было на клон-языке указывать.
тогда всякие плагины.. пишут функции на клоне и это и будет клон-команды.

ну либо по мотивам питона - команда это загрузка модуля
python -m SimpleHTTPServer
npx packagename и в частности npx url
а еще есть npm create packagename... но у нас нет пока реестра.

т.е. clon cmd args
это на самом деле загрузка модуля cmd и передача ему управления.
это кстати даже дешевле будет - всех загружать не надо.
ммм. ну и можно точку входа придумать, типа func "clon-call"

но и идея что заполняем окружение функциями так-то красивая.
но и дальше - идея о том что не clon init-web а clon add web; clon web
...

*****************
таки подумать о способе вызова функций. сейчас они через объект-каллер делаются (по сути реакцию). и фибоначчи от 17 считается несколько секунд!
*****************
разбор операторов и callstyle-вызовов

func "fib" { n |
  // print "fib called" @n
  if (@n > 1) {
    //return ((fib (@n - 1) + (fib (@n - 2))))
    // вот это распознается криво.. как 3 несвязанных операции
    res := fib( @n-1 ) + fib( @n-2 )
    // и вот это тоже
    // res := 10 + (fib (@n-2))
    // а вот это распознается
    // res := (fib (@n-1)) + (fib (@n-2))
    // и вот это норм
    //res := plus( fib( @n-1 ), fib( @n-2 ) )
    exit @res
  } else { exit @n }
}

x := fib 10
print "x=" @x

**********************
все-таки os.spawn должна давать на выход именно поток а не просто канал-порт.
чтобы поток мог закрыться.
тогда - будет работать wait ===== ловя такие закрытия, даже если не было записей в output.

***********

* плохо проработаны арифметические операторы.
	* кстати идея как сделаны они в lua - там метатаблицы и оператор к ним обращается и получается разные сущности можно складывать вычитать и прочее.
* плохо проработана работа с детьми.

* map-parallel уже надо. а то тесты долго работают.

******************
надо нормализовать узлы которые выдает pegjs.
- сейчас там много лишнего.
- в подвыражениях даются ссылки на features_list а 
это неправильно надо именно expression значение да и все.

предлагается что-то вроде:
basis: name | array
pos_params: array
named_params: dict
и всё...

ну или не named_params а просто params.
- удобно что кол-во позиционных параметров известно через pos_params.length и удобно добавлять (unshift или push)
- детей мы решили хранить как значения параметров..

ну и вот такие получается у нас структуры.

ну или 
params и params._pos например.
или
params + pos_param + named_params.
где в params все - а в других только то что про них. но неудобно добавлять - надо в два массива.. нет уж, лучше в одном пусть месте будут.

ну либо оставить как было, т.е. все в params, а дополнительно count - кол-во параметров.. но тогда unshift не сделаешь. ну да.
=======

Удалить next_obj_param фичу

**********
таки научить react реагировать в режиме any на перечисленные аргументы.
т.о. он форма.

и уже мб ввести время. выяснено, что если вводить время то мы получается делаем честный автомат, а реакции становятся правилами по разбору его слова. при этом само входное слово становится длинным - оно есть комбинация всех входных каналов(=слов).

*******
нужны именованные аргументы для функций
func "map" {: arr batch_size f| ... :}
map @data batch_size=10 f

для этого надо научить generate_func_caller использовать аргументы по-нормальному.

-----------
bind (dom.event @btsearch "click") @do_search

-----------
нужно что-то типа action. или подумать как такое делать своими средсвтами.

*****
на самом деле уже пора проверять что ссылки существуют.
т.е. пишем alfa=@some.foo и надо выявлять что эта some.foo есть.
источики у нее:
- ячейки и каналы
- параметры
- импортированные окружения
- созданные объекты
- но как проверять вещи вида @objid.objcell ?
F-TODO-CHECK-NAMESPACES

update подтверждаю а то ждал @k.exit_code а ее неиту..
**********************
В следующем примере Qq никогда не напечатается.
Потому что k1 никогда не выдаст ничего наружу.. т.к. inherit не пишет в каналы
print "starting web dev"
import os="std/os.cl"

k1: os.spawn "clon" "compile" stdio="inherit"
print "compiled" @k1.exitcode
================
print "Qq"

===================
но самое главное. вот если слон будет провоцировать создавать программы с ортогональным наполнением фичами, вот это будет его мега-фишка.

*****************************
```
mixin "tree_node"
process "node" {
  in {
    cf&: cell
  }

  apply_children @cf
}

enva: node {
  a: cell 10
  b: channel  
}

print "ee=" @enva.a
```
a b никогда не будут элементом enva т.к. self не назначается..
вероятно, с учетом что это child-функция, стоит назначить self.

*******
when-any вынести на cl-уровень.
да и вообще бы разобраться что у нас там есть по этой теме. а то много всего.

*******
надо уже убрать features.
и ввести параметру значение - вот подвыражение. это упростит все я думаю.
links останутся чистыми - на внешнее
========
надо splat уже делать..  a := list (value) ...@other_list

==========
сделать аксессоры как написано в заметках 2023-12-16.
==========
сделать уже react @a @b {: a b | .... } !!!!!

--------
сделать рест-подстановку из выражения т.о. some **(compute ..)
subgr (get @sv "id") **(get @sv "params")



===============
di: dom.input
sd: simple_data_target @rapi (+ @pid "/" @name "(cell)") @di.output
// @di.output -> @sd.input мб так лучше? попробовать..

===============
вот в чем в слоне проблема - не могу сделать ссылку на объект.
т.е. я бы хотел чтобы в x хранилась среда, и с ней реактивные операции всякие.
но при этом чтобы я x мог менять. и операции пересчитывались.
всякое типа
x: someenv не подойдет - это тяжелая ссылка.
ну а 
x : cell
... submit (x, x1=someenv)
может и подойдет, но как тогда сказать @x.somechannel ? или get @x "children" ?
или это вопрос как раз аксессоров?

=============
надо как-то так адаптеры для языков сделать, чтобы там было совершенно ясно
что надо делать чтобы оно компилировало.
мб даже по этапно и по шагам. а сейчас это крайне неудобно.
и более того - я заметил что часто меняю что-то в js модуле, что в принципе
пригодилось бы всем языкам. стало быть разбиение какое-то неправильное.

=============
подумать о подключении https://c9x.me/compile/
ибо это в принципе вариант развития событий.
но - надо тогда чтобы язык работал не на уровне {: .. :} кодов
а на уровне своих инструкций. чтобы уйти от этих вставок вовсе
оставить их ток на базовом уровне - типа они как ассемблерные вставки чтобы были.

=============
а язык на базовом уровне это отдельная история. у меня до сих пор нет какого-либо
удачного понимания, как сделать его удачным.

кстати как вариант - старая мысль. что да сделать такой язык но особый режим исполнения,
тот же функциональный - например разовое исполнение. т.е. операции как функции.
но они должны сообразно уметь порождать и процессы. вот это вот сообразить..
(модель Мультиклет? или по сути - таск граф? но что делать если реально связь на вход это не обещание а канал? понять.)

а так конечно хорошо:
button "click" {:
  x := load "a.txt" | parse_csv | reduce_column "A" {: val acc | @val + @acc :} 0
  apply @console.print "x is" @x
:}

собачки лишними кажутся. а что если ну вместо собачки просто символ? но это символ это есть процесс, который возвращает значение указанной скажем ячейки. тогда как мы знаем ток вопрос отделения аргументов. т.е. как в записи
button "click" {:
  x := load "a.txt" | parse_csv | reduce_column 
          "A" 
          {: val acc | val + acc :} 
          0 
  console.print "x is" x
:}
понять что console.print это уже следующий оператор а не позиционный аргумент для reduce_column ?
хотя опять же как мы знаем ; спасла бы положение. но с ней тяжело - ее забываешь ставить.

ладно. главное сначала модель вычислений допонять - что я хочу и как я это вижу. а затем уже синтаксис.

================
баг
x: obj ....
process "a" {
  in {
    x: cell
  }
  // но теперь x это глобальное имя и оно не стало локальным от того что x затенился локальным аргументом
}