# F-REST-SUBST
сделать rest-подстановку при передаче позиционных аргументов: 
`print *@arr`

-----
F-DESTROY-EXPR
Удаление объекта долно приводить к удалению и его под-выражений (они идут в attached-дереве).
a: foo (some (expr))
... a.destroy() - должно удалить и some и expr.

-------
- таки сделать установщик пакетов. хотя спорно, надо ли. может быть проще заюзать нодовский.
но попробуем для интересу.

- таки сделать что не надо func указывать. а именно пишем везде {: :} и это есть переход в вычислительный режим. хотя чем он щас отличается мне не очень ясно ))))
но в целом - просто уйди от анонимных func типа {= =} и {: :} это и есть функ.

- подстановка параметров *rest и **named_rest а также параметр named_rest**
- dict alfa=.. beta=.. создает "словарь"

- состояния и переключения между ними. где-то я читал что это удобно. ну и типа вот процесс и он перключается между состояниями и его куски активируются и деактивируются. в целом это как if но синтаксически красивее.

- попробовать bind с разными параметрами. так-то интересно.

*
reduce_events научить работать с ко-функциями. и мб как следствие react научить буферизации.

**********
все-таки нужна последовательность действий тоже. сначала сделай это, потом сделай то.
например при взаимодействии с внешними системами.
мысли:
* seq { ... } и внутренние вещи тогда будут последовательно
* {~ ... } и типа ~ задала нам флаг что последовательное исполнение
* оператор ===== и он типа дожидается чтобы было сделано все что сверху, а затем активирует следующий блок.
можно нисколько таких, т..е
print 1 === print 2 === print 3
ну наверное не === а ~~  или другое какое-то
print 1 ~~ print 2 ~~ print 3

в принципе пока можно обходиться так:
apply { return (print 1) } | apply { return (print 2) }
если сделать автоматический ретерн для окружений из 1 оператора,
а apply заменить на символ, то будет
% { print 1} | % { print 2 } нет уж лучше символа не надо )))
*******
