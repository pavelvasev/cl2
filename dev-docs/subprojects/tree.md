F-TREE

Необходимо группировать объекты-процессы в деревья.
Чтобы описывать иерархии. Это надо для интерфейсов, для 3д графики.
При этом чтобы сохранялась возможность описывать и функции на Слон-языке.
И при этом чтобы работали вещи типа if, repeater. 
В частности чтобы if cond { dom.element .... } добавлял этот dom.element в своего родителя и желательно в то место где стоит if а не в конец.
А и кстати if и т.п у нас сделаны такими, что их аргументы это функции.

Решение следующее.

**************** 1

Вводятся понятие:
- обычный узел дерева tree_node
- лифт-узел дерева tree_lift

Все они имеют методы добавления объектов в список своих детей (append)/
При этом при обходе, если такой узел видит среди детей узел типа tree_lift,
то он добавляет не его, а его детей.

Таким образом получается. Что вычисления, а равно и вещи типа if, объявляют себя tree-lift-ами. Подобъекты добавляют себя в них как обычно. Но при этом их подобъекты в итоге телепортируются в целевую область - например туда где был if, что и требуется.

*************** 2

Функции научены возвращать 2 типа аргументов.
1. Обычное значение, аля канал output.
2. Лифт-объект, который готов передать список детей.

Эти вещи группируются в func_process. Таким обьразом каждый раз когда запускается {}-код как функция, то создается func_process. Вложенные объекты дерева - цепляются к нему как к лифту. Ну а всякие return шлют данные в канал output.

**************** 3

Уже давно решено что "дети" автоматом никуда средой не добавляются, а передаются как функция-аргумент в родителя.

Для родителя добавлена функция apply_children @f которая запускает фукнцию f и объекты созданные в ней - добавляются в родителя. 

Реализовано хорошо - apply_children заявила себя tree-liftom, при вызове функции (которая тоже создает контекст типа tree-lift, см func_process) соединяет ее контекст с собой. Таким образом через 2 звена дети из описанной слон-функции и поступают в родителя.


----------------------------------------
---------------------------------------- из невошедшего
----------------------------------------

2023-10-05 модель дерева детей.txt

вот что мы выяснили.

есть роли
- готов быть родителем
- готов быть ребенком
- готов быть сборщиком.

родитель - в нем организуется процесс сборки детей.
результат процесса этого это список объектов детей.

ребенок - подает заявку на вступление в дерево.
кому он её подает определяется в процессе компиляции,
есть такая переменная в state компилятора.
важно что это только подача заявки.
она регистрируется тем, кому она подана.

сборщик - собирает заявки и.. а вообще кстати ведет себя
как родитель. за одним исключением. он не ставит
детям флаг что он теперь есть парент.
а так - он проводит процесс сборки такой же как родитель
проводит.

так вот процесс сборки он учитывает
- заявки на вступление к нему в дети.
при этом: если заявитель сборщик. то добавляется не он а его "дети".
(ну они ему и не дети, а собранный список объектов).
вот и все. вот и вся модель.