Тема миксинов очень важная.

Сделаны такие миксины:

1 - mixin "name" "name" obj "target" { }
2 - mixin "name" "name" { obj ... obj .. }

где name это имя obj которое уже определено ранее, и эти указанные obj подмешиваются в создаваемый obj

Этого оказалось недостаточно - надо уметь передать параметры этим создаваемым объектам.
Причем параметры видов: константа, ссылка, и параметр-константа (который еще не сделан).

Поэтому добавлены такие миксины.

3 - imixin { spec spec.... }
4 - imixin { spec spec... } @target1

вариант 4 это экспериментальный - по идее динамически создает объекты spec но в рамках объекта @target1.

=========
Это мы еще не сделали prepend, который методы соединяет как в Руби.
Надо посмотреть как вообще пойдет. Т.е. сейчас считается что непересекающиеся вещи добавляются, которых нет в целевом объекте.

Ну и еще у нас есть base_class.

Продолжаю наблюдение.

-----
в новых миксинах конфликт по входным переменным.
Пример. В lib3d.points я хочу чтобы было positions. 
И чтобы оно наследовалось-миксовалось с lib3d.element.
Если position объявить в in-переменных points (что в целом логично) то будет конфлик с position-ячейкой из element..

================
2024-02-29

1 mixin неудачно - лучше prepend. А то мысль что это миксин.
2 сделать установку mixin-ов может так:

prepend "mixin-name" params.... {
  цели..
}

prepend { mixin-name params.... mixin-name2 params... } {
  определения целей
}

кстати как вариант тогда в первом варианте без кавычек, для единообразия.
язык слегка меняется, но это особая форма. ведь if ... then ... else ... нас не пугают.

И желательно как-то отдельной операцией тоже уметь. т.к. Руби например может: classname.prepend mixin

например
prepend { .... } "class1"
хотя тут кавычки как бы лишние будто.. ну или
prepend { .... } { class1 class2 }
но тогда уж хочется и динамическое:
prepend @mixins @targets...
