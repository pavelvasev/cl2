## Причины появления СЛОНа

### Кратко
1. Нужен язык для лаконичного описания процессов (а не только функций).
2. Чтобы программы на нём можно было транслировать на разные целевые платформы (например Javascript, C, ассемблер)

### Длинно

Разработка CLON (и его предыдущей версии, [Compalang](https://github.com/viewzavr/vrungel/tree/main/develop/compalang)) иницирована следующеей идеей.
В компьютерных вычислениях важную роль играет важное поняние - процесс.
Процесс - это что-то происходящее ("живое"). 
Классические языки программирования предлагают описывать процессы с помощью функций.
Возникла идея попробовать описывать процессы "напрямую".
<!-- Так, функция технически может создать (инициировать) процесс. Например, зарегистрировав "обработчик события".-->

Прикладная потребность состояла в том, чтобы программировать сцены визуализации. Это включает в себя: 
* описание визуального образа (в форме композиции составляющих элементов) и его взаимодействие с пользователем,
* двумерный (кнопочно-менюшный) интерфейс,
* преобразование данных.
<!-- Первоначальный прикладной замысел состоял в создании языка для описания сцен визуализации и управления ими. -->

Пример полученного языка:
```
a: load-file name="coords.txt"
b: parse-csv input=@a.output
c: slider min=1 max=10
points positions=@b.output radius=@c.output
```
Здесь load-file, parse-csv, slider и points это процессы, между параметрами которых установлена связь.
При изменении значения какого-либо параметра обновлённое значение пересылается по связи, а процесс-владелец параметра получает уведомление.

Быстро выяснилось что возможно и удобно составлять "выражения" из процессов. Выражение возвращает значение на параметре .output соответствующего процесса. 
Пример выше выглядит с выражениями так:
```
c: slider min=1 max=10
points positions=(parse-csv input=(load-file name="coords")) radius=@c.output
```
Если ввести оператор соединения процессов `a | b` (конвейер), который создает связь параметров a.output и b.input, то получается более приятный для восприятия вид:
```
c: slider min=1 max=10
load-file name="coords" | parse-csv | points radius=@c.output
```

Далее быстро выяснилось, что описывать процесс только из составляющих процессов недостаточно. Все-таки "функции" оказались тоже нужны. 
Например, чтобы задать действия, которые следует предпринять в ответ на событие.

Появилась идея использовать синтаксис CLON для описания таких действий. В режиме действий модель вычисления изменена. 
Действие выполняется только один раз. Оно начинает свою работу когда все аргументы "готовы". То есть если они связаны с результатами других действий,
то те другие действия должны предоставить свой результат. (в целом это как вычисление аргументов функции но без ограничения что они выполняются "слева направо").

Пример описания действия:
```
p: points ...
window on_click = { info |
  info := intersect_3d @window (list @info.x @info.y) @p
  pos := slice @p.positions (3 * @info.index) 3 // сработает когда вычислят info
  print "нажали точку с координатами" @pos // сработает когда вычислят pos
}
```
### Реакции
Было выяснено, что сердцевину процессов составляют так называемые реакции.
Реакция это действие, которое следует предпринять в ответ на появление события.
В этом смысле "обычные" языки вполне себе описывают процессы, когда
регистрируют обработчик какого-либо события. Например, указывают callback, продолжение для обещания (`some.then( callback )`) и т.п.
Цепочки и деревья вызовов таких callback это и есть "ход" процессов.
Это хорошо согласуется с CSP Хоара, когда описывается что при поступлении события процесс ведет себя "так-то и так".

Таким образом для описания процесса формально достаточно:
- перечислить каналы для связи с внешним миром (входные, выходные).
- перечислить реакции на поступление информации в этих каналах ("события").
И для удобства описания надо включить возможность использовать вложенные процессы (выразительность языка по Сассману).

И видимо для выразительности - сделать процесс реакции на события рекурсивным, в смысле чтобы действие реакции могло порождать новые реакции.
Например у Хоара это само собой, когда пишут `x -> (y -> P)` то значит "при событии x порождаем новый процесс, который есть реакция на событие y".
И в обычных языках это видимо тоже - когда пишут `promise.then( r => .... ).then( ... ))` то второй then это по сути реакция внутри реакции.

Приведенное понимание обнаруживается во многих языках. Например в языке [Lingua Franca](https://www.lf-lang.org/docs/handbook/overview?target=c). 
И дополнительно там введена модель времени, структурирующая порядок выполнения реакций. Язык СЛОН вдохновляется успехами Lingua Franca. 

### Заключение и перспективы

1. Как сейчас видится, задача описания процессов в принципе решена.
Понято, из чего должен состоять процесс (каналы синхронизации, связи между ними, реакции, подпроцессы).
Это очень хорошее понимание ("база"). Но в принципе языки не обязаны явно оперировать этими вещами,
а могут вводить свои метафоры для пользователя, которые уже внутри себя опираются на эти.
3. Дополнительно, введён синтаксис описания связей между подпроцессами (см. выше выражения из процессов).
4. Дополнительно сделана попытка описать действия, превращая процессы обратно "в функции", которые выполняются 
на основе т.н. частичного порядка (по готовности данных).

Полученный язык и его транслятор имеют хорошие особенности:
1. Теоретически транслироваться в разные платформы. (но не решался вопрос сборки мусора в режиме действий).
2. Быть универсальным языком для интерфейсов, скриптов, серверов, сцен визуализации, систем реального времени и быть может параллельных программ.

### Открытые вопросы
Есть много открытых вопросов. Среди них:
1. Удобно ли будет пользоваться частичным порядком при описании действий.
2. Как описывать реакции рекурсивно? (потребность см. выше). В "обычных" языках это решено на удивление изящно.
(т.о а так ли уж они плохи?) Быть может тут помогут так называемые "состояния".
Они обнаруживаются и LF, и во многих других, да и Машина Тьюринга похоже построена на состояниях, которые в ней есть коллекции реакций.
3. А нужна ли в принципе была эта история, если можно использовать декораторы (в духе Питон) как генераторы процессов? Например порождать действия запускающиеся по готовности данных, с параметром - указанной функцией. Но с другой стороны мы описали процесс, а затем ведь его надо использвать и увязывать с другими процессами...

См. также раздел [открытые вопросы](open-questions.md).
