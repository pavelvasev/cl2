// F-TASKS

import * as C from "../../lib/cl2-compiler.js"
import * as FORMS from "../forms/forms.js"

let default_cp = (assigned_names) => { return {normal: assigned_names, renamed: {}, pos_rest: [],named_rest:[]} }

export function init( state, tool )
{
	
	state.env.cofunc = { make_code: cofunc, check_params: default_cp}
	state.env.func = { make_code: func, check_params: default_cp}

/*
	let task_code = `
obj "task" {
  in {
    input: channel
    action: cell
  }

  output: cell

  b: react @input @action

  bind @b.output @output

  b2: react @b.output {: b.destroy(); b2.destroy(); :}
  // мы не вызываем self.destroy т.к. у нас output, на него подписаны..

  //react @input {: console.log('cofunc started',self + "") :}
  //react @b.output {: console.log('cofunc finished',self + "") :}
  
  // todo
  }`
	let task_code_lang = tool.compile_string( task_code, state )
	tool.add_global_code( "// from compute plugin",task_code_lang )
*/

}

/*
export var tablica = {
	let: { make_code: _let, check_params: default_cp }	
	//,reaction: { make_code: reaction, check_params: default_cp}
	// return..
}
*/

// в общем щас я пока просто по 2 случая реализовал. и есть кое где дублирование кода.
// todo объединить если тема зайдет.

// вычислительный режим
// cofunc {} - на выходе даёт объект где output функция
// cofunc "name" {} - на выходе регает функцию + регает объект вызыавющий эту функцию в режиме apply
export function cofunc( obj, state )
{
	//console.log("EEEE2")
	let name = obj.$name_modified || obj.$name
	let anonymous_mode = obj.name_is_autogenerated ? true : false

	if (obj.params[0]) { // вариант func "name" code
		name = obj.params[0]
		anonymous_mode = false
	}

	// поменяем особые формы
	let modified = C.modify_parent( state, "self",null )

	modified.next_obj_cb2 = ( obj, objid, strs, bindings, bindings_hash_before_rest, basis_record ) => {

		strs.push(`${objid}.task_mode = true`)
		return

	  let source_comms = Object.values(bindings_hash_before_rest)

	  if (source_comms.length == 0) return;	  
	  // нет зависимостей - ну сразу делаем

	  // пропустим также некоторые спец-процессы.. это хак..
	  // if изза else надо тоже сразу делать (else пытается себя в if впихнуть)
	  // return ну уж до кучи тож
	  if (obj.basis == "if" || obj.basis == "return") return
	  // новая метода - если объект то остается объектом.	  
	  // но если это был объект который вызывает функцию - то пропускаем
	  if (!basis_record?.obj_record?.params?.func_caller) {
	  	//console.log("cofunc: basis_record not func_caller, skipping",objid,basis_record?.obj_record)
	  	return
	  }

	  //strs.push( `let ${objid} = create_task( ${objToString( {consts:init_consts,basis_func:obj.basis, bindings_hash},,1,state)} )`)
	  let r_strs = []
	  let r_id = `${objid}_task`
	  r_strs.push( `let ${r_id} = create_task({})`,
	  	`let ${objid} = ${r_id}; ${r_id}.attached_to=self; ${r_id}.$title='${r_id}';`, // внешние ссылаются по старому имени
	  	//`${r_id}.action.set( () => { `,strs,bindings,`if (${objid}.output) CL2.create_binding( ${objid}.output, ${r_id}.output`,` })`,
	  	`${r_id}.action.set( () => { `,[...strs],[...bindings],
	  	`return ${objid}.output`,` })`
	   )
	   //console.log('cofunc action started: ${r_id}',${r_id}+'')\n 
	   //,`${r_id}.output.once( () => console.log('cofunc action finished: ${r_id}',${r_id}+'') )\n`,


	  // заменяем
	  strs.splice( 0, strs.length, ...r_strs )
	  //console.log('strs replaced:',strs)
	  bindings.splice( 0, bindings.length,`CL2.create_binding( CL2.when_all_once( [${source_comms.join(',') }] ), ${r_id}.input )`)
	}

	let s = C.objs2js( C.get_children( obj ),modified )

	//console.log("in called. result=",base)
	let self_objid = C.obj_id( obj, state )
	let args="", args_cells=""
	let head = C.get_children_head( obj )
	if (head) {
    	args = head.attrs.map(x => "__" + x).join(",")
		//return { main: [`CL2.mark_task_function( (${args}) => {`,s,"})"], bindings:[] }
    	// поскольку мы выдаем функцию.. то на вход идут конкретные значения
    	// но в коде мы считаем их коммуникац. примитивами. и поэтому мы их оборачиваем в примитивы, эти значения.
		args_cells = head.attrs.map(x => `let ${x} = CL2.create_cell( __${x} )`)
	}


	if (anonymous_mode) {
		let output_things = [`let self = {attached_to:${self_objid}, $title: 'cofunc_action'};`,"let output = CL2.create_cell();","CL2.attach( self,'output',output )"]
		let func_code = [`CL2.mark_task_function( (${args}) => {`,args_cells, output_things, s,"return output","})"]
		return generate_func_object( self_objid, func_code )
	}

	// отличается тем что убрано attached_to
	// хотя можно было бы вызывающего туда писать, что уж тут.. ето ж экемпляр конкретный..
	let output_things = [`let self = {$title: 'cofunc_action'};`,"let output = CL2.create_cell();","CL2.attach( self,'output',output )"]

	let strs = [`function ${name}(${args}) {`,args_cells, output_things, s,"return output","}"]
	strs.push( `CL2.mark_task_function(${name})` )
  strs.push( `CL2.attach( self,"${name}",${name} )` )

	//state.current[ name ] - а кстати идея.. зарегать так объект..
	state.static_values[ name ] = true
	// .static_values это тема, чтобы на функцию не биндиться а как есть передавать

	//console.log("generating caller for",name)

  let caller = generate_func_caller( name, state )
	strs.push( caller.main )
	return {main:strs,bindings:[]}
}

// создает объект, возвращающий в .output код функции
function generate_func_object( self_objid, func_code ) {
	return { main: [`let ${self_objid} =  CL2.create_item()`,
				`let ${self_objid}_output = CL2.create_cell(`,func_code,")",
				 `CL2.attach( ${self_objid}, 'output',${self_objid}_output )`],
			     bindings:[] }
}

// создает объект name, который вызывает указанную функцию при смене параметров
// идея - чтобы можно было говорить func "x" а потом писать (x 1 2 3)
// по сути тело то это apply, не знаю зачем я это дублирую?
// todo тут надо параметры перечислить функции.. тогда появится проверка типов уровня obj - красота
function generate_func_caller(name, state) {
	// todo это просто apply, надо только *rest передать и все.
	// хотя не совсем.. еще сигнатуру соблюсти надо.
	// но тогда это и не rest
	let code = `
	 obj "${name}" func_caller=true {
	 	  in {
	 	  	rest*: cell
	 	  }
	 	  output: cell
	 	  vals: extract @rest
  	  r: react @vals.output {: args |
  	    if (self.task_mode) {
  	    	// console.log('ok taskj')
  	    	// r.destroy() xxxx
  	    	if (self.started)
  	    		 console.log('FUNC duplicate call!!')
  	    	self.started = true
  	    }

  	    return ${name}( ...args ) 
  	  :}

  	  bind @r.output @output
	 }
	`
//console.log("autogen",code)
	let c_obj = C.code2obj( code )
	let strs = [C.objs2js( c_obj,state )]

	return {main:strs,bindings:[]}	
}

let ccc = 0
// действие типа "функция"
// func {: :} - на выходе даёт объект где output функция
// func "name" {: :} - на выходе регает функцию + регает объект вызывающий эту функцию в режиме apply
export function func( obj, state )
{	
	//console.log("EEEE")
	if (C.get_children( obj ).length > 0) {
		//console.log("func obj have ch", obj)
		return cofunc( obj, state)
	}

	let name = obj.$name_modified || obj.$name
	let fn_code = obj.params[0]

	let anonymous_mode = obj.name_is_autogenerated ? true : false

	if (obj.params[1]) { // вариант func "name" code
		name = obj.params[0]
		fn_code = obj.params[1]
		anonymous_mode = false
	}

	if (anonymous_mode) {
		let self_objid = C.obj_id( obj, state )
		let code = [`function (${fn_code.pos_args.join(',')}) { ${fn_code.code} }`]
		return generate_func_object( self_objid, code)
	}
	
	//console.log('fn name=',name,'dir=',state.dir)
	let export_flag = state.dir == '' || state.dir == './' ? 'export ' : '' // todo перенести это в bundle-2
	let strs = [`${export_flag}function ${name}(${fn_code.pos_args.join(',')}) { ${fn_code.code} }`]
  strs.push( `CL2.attach( self,"${name}",${name} )` )

	//state.current[ name ] - а кстати идея.. зарегать так объект..
	state.static_values[ name ] = true
	// .static_values это тема, чтобы на функцию не биндиться а как есть передавать

  // todo это надо как-то соптимизировать. по сути нам надо сгенерировать объект
  // что-то типа define_obj_from_func "${name}" ${name}
  //console.log("GGG",name)
  let caller = generate_func_caller( name, state )
	strs.push( caller.main )
	return {main:strs,bindings:[]}
}