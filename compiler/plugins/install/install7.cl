import os="std/os.cl", fs="std/fs.cl"

map(config.modules) { |name value|
  let dir = module_dir(value)
  ~ clone_sync(value.src,dir)
}

func module_dir_name { |module_record|
  // https://github.com/pavelvasev/cl2threejs.git
  split(module_record.src,"/") | last() | split(".") | first()
}

func module_dir { |module_record|
  let dirname = module_dir_name(module_record) // вычисление имени каталога модуля
  let dir = +("./cl-modules/",dir)
  ~ dir
}

func clone_sync { |src dir|
  if (fs.exist(dir)) {
    os.exec("git pull",cwd=dir)
  } else {
    os.exec("git clone",src,dir)
  }
}

здесь return заменено на символ.
ну и в целом я думаю что можно сделать так что если только 1 окружение
то return можно не писать т.к. понятно из чего результат.
а вот если несколько - то тогда можно даже и требовать его наличия.
ну в случае func/cofunc.

===

в этой версии что мы в целом видим. что выделены структурные операторы в отдельный синтаксис.
ну среди таких
- let он не требует писать скобочек. но если там две параметры то нужны уже запятые.
- return тоже не требует скобочек
- ну для if тоже может быть..

в целом будто бы... 

ну что такое скобочки - это оператор обращения к eval на самом деле. типа если без них 
то это ссылка на переменную, а со скобочками - операция обращения.
но типа let, return на них не надо ссылаться?
но кстати а вот if - вполне себе можно представить и функцией на которую сослаться.
но опять же если надо на if сослаться то может быть удобнее - оформить его в лямбду.


----------------
короче

итак функция у нас это вычислительный процесс. как его ты не крути.

функция получает управление. а точнее даже она получает задание на исполнине.
и нначинает исполнятсья согласно плану изложенному далее.

а план это обращение к другим функциям.

  и там еще несколько управляющих операторов мы выделяем - let, return, ну может if.
  но т.е. не много. ну может еще map но зачем.
  там замысел просто поменьше скобочек писать.
  но можно пока их и писать, делов то.

но и того. она получает такое задание на исполнинение. начинает делать.
и далее она обозначает где брать результат этого всего.
т.е. что считать результатом задания. она это явно обозначает через return.

----
но в целом будто бы проблемы мои не изза синтаксиса.
синтаксис будто бы вытерпит. он пока более менее вроде как.

проблемы то принципиальные..

**********************************
ну вот они видимо завязаны, эти проблемы, на незавершенность темы функций.
ну я так предполагаю.

а именно надо научить функцию.. определяться через cofunc-синтаксис..
и обратно, чтобы func была объектом которая возвращает просто функцию.

ну или.. ну что-то такое..

т.е.

print (apply (func { |alfa| alfa + 1 }) 10)

ну формально тут 2 режима. func с именем - вводит в окружение. а без имени - генерит функцию.
ну можно в форме .output, можно просто в текстовой форме тут же инлайн..
наверное..

но хотелось бы и:

print (apply (func {: alfa| return alfa + 1 :}) 10)

