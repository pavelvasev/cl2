let вынесено как особая форма на текстовом уровне.

****
вообще найдено уже 3 особых формы
- синтаксиса
  добавляет свой синтаксис
- объектного преобразования (со своим синтаксисом или со стандартным)
  преобразует список объектов пропарсенных, заменяя себя на что-то другое.
- текстовая - генерит свой текст. 
****

объектная и текстовая особые формы - к компилятору не относятся они внешний для него параметр.

****
create-binding делается в привязке к объекту.
ну а точнее - объекту на release ставится удаление биндинга.
надо ли ему хранить сами биндинги еще вопрос.

*********************
сборка набора оставшихся позиционных параметров в общий параметр с маркером *
сборка набора оставшихся именованных параметров в общий параметр с маркером **

подстановка набора позиционных параметров с маркером *
подстановка набора именованных параметров с маркером *

**********************
статическая проверка типов. каждый тип должен предоставить функцию check_params
на вход берет имена на выходе - списки normal, rest_positional, rest_named.

**********************
F-DELAYED-EATER
преобразователь каналов с переводом в следующий логический такт и уборкой дублирующихся

**********************
F-ANNOTATE
к ячейкам и каналам нужна аннотация - что они такое. надо для отладки. а то не очень понятно что когда и почему происходит. 
итого каждый объект синхронизации пусть имеет title.

причем аннотация должна получаться путем своего title и вызова title() к чему приаттачен данный примитив. функция потому, что хост-примитив могут тоже приаттачить, но когда-нибудь

*********************
F-POSITIONAL-RENAME
пишем someobj @a @b @c 4 5 6
и они идут как params.0, params.1 и т.п.
и надо как в питоне - переименовать их.

***********************
F-BIND-OBJECTS
идея - чтобы bind работала и с объектами.
т.е. есть obj1 и пишем bind @obj1 @x
и это можно, если у obj1 есть примитив output

***************************
F-FEATURE-OBJ-NAMES-UNIQ
оказалось что вещи типа
foo alfa=(add @beta 10 (counter (timer))) sigma=(counter (timer) 111)
порождают одинаковые идентификаторы (типа _counter)._

в общем среди решений пробовал префиксы но там сложнго. в итоге на уровне пег-парсера порождаются идентификаторы с уник. счетчиком.


**************************
F-COMPILER-PLUGINS

Решено компилятор оснащать плагинами а то там много фич которые захочется в будущем менять.
Плагин подключается передачей к нему управления в функцию setup(state) где state корневое
состояние. Плагин может вписаться в него.

Используется точка сопряжения state.space - одни плагины вызывают методы из нее, другие туда добавляют методы.

**************************
F-MODULE-PATHS

модули резолвятся следующим образом
import localname="someid/some/path"

* если someid это . то тогда some/path локальный
* иначе
используется карта импортов которая резолвит someid в каталог или в путь
(по аналогии import maps в js) и далее приписывается some/path.

таким образом, 
import d="std/dom/dom.cl"
загрузит файл lib/dom/dom.cl если std указано в карте импортов как путь к каталогу lib.

*********************
Принцыпы CL2 принципиальные.

- канал, ячейка, метод - отдельные сущности

- стыковка объектов (один в другой) типа делаем окружения. иерархичные причем.

- трансляция и затем исполнение. не принципиально но - позволяет использовать компилятор внешний для неитнересных задач таких как работа с окружением, визуальная отладка..
- ну вроде как не принципиально какой целевой язык. делаем рантайм на нем а вокруг - сгенерированный код опирающийся на рантайм.
- модульность. под ней имеется ввиду пространства имен. это очень важно оказалось.
т.е. подключаемый модуль не вписывает свои штуки в текущий контекст (окружение) а остается как бы внутрях своего окружения. ну тут возникает задача мержить повторно использьуемые модули чтобы копий не плодить, она решается.

- проверка параметров при компиляции. т.е. если передают неверное кол-во параметров или неизвестный параметр именованный - выдать ошибку. практика CL показала что это очень частые ошибки и их долго ловить.
как следствие - некоторые параметры надо описать как входные, причем порядок важен (для позиционной записи передачи параметров)

- потом надо еще сделать и ссылочную проверку - ссылаемся на прибинденный подобъект так надо проверить есть ли он там.

- смешнивание позиционных и именованных параметров аля Питон. Признано очень удобным моим личным опытом юзанья Питона. Возможность сбора неограниченного кол-ва позиционных *rest и **rest именованных параметров. Подстановка параметров, т.е. print *arr


====================
F-PLATFORM-CODE
сделано {: a b c | code :} для вставки платформенного кода. оч удобно.

------
F-CHILDREN-BLOCK
иногда надо не автоматом создавать детей у объекта а передать ему в параметрах.
например для реализации repeater, if, да и вообще всех кто может трактовать содержание вложенных {} по-особому. 

Реализовано как в руби - если в имени параметра есть & то ему передается описание содержимого {} а не сами объекты. Передаются сейчас пока в форме функции вида foo: parent -> void
которая создает процесс описанный в {} включая объектов детей и цепляет все это в указанный parent.
Можно вызывать несколько раз.

F-CHILDREN-BLOCK-PARAMS
возможность передавать чилдренов в форме
foo { |x y|
  std.print @x @y
}
тогда они поступают в форме функции у которой доп. параметры - ячейки/каналы.

F-PARAM-OBJECTS
Запись вида alfa b={ sigma gamma }
т.е. в параметр b можно передавать блоки. Равно как и блоки вида { |x y z| .... }.
Правило такое же как и с детьми - передаются в форме функции с параметрами - целевым родителем и позиционными параметрами-ячейками/каналами.

F-IF
Операция if
if @cond @then_value @else_value
if @cond {
  then-block
} else {
  else-block
}

-------------------------
F-DEFAULT-CL
Дефолтные вещи, т.е. объекты и формы доступные всюду, - задавать в том числе на cl-языке.

F-STATIC-VALUES
Проблема - some @func и вот func имеется ввиду это функция где-то выше определенная.
а мы начинаем пытаться ее забиндить в аргумент.
Поэтому - вводим отслеживание статичных значений.

----------------------------
P-SPECIAL-NAMES

Проблема - в операциях могут быть символы всякие корявые типа +, < и т.п.
и так функции в js нельзя называть да и в других языках иногда тоже
с этим необходимо что-то делать.

варианты:
F-SAFE-NAME
поэтому надо преобразовывать cl-имена в варианты, безопасные для целевого языка
- при определении объектов и функций
- при их использовании в basis и по ссылкам тоже
кстати про ссылки - значит надо разрешить точку в именах... (т.е. используем оператор доступа к полям объекта из целевого языка)

единственное проблема - как в ссылках ссылаться на функции с такими именами?
т.е. @+ вряд ли получится..

F-ALIAS
мы делаем нормальное, платформенное. например "plus"
а потом говорим alias "plus" "+"
и она уже ползет пусть в env и там делает как надо..
